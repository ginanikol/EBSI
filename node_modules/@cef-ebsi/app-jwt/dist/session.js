"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const jose_1 = __importDefault(require("jose"));
const utils_1 = require("./utils");
const constants_1 = require("./constants");
const utils = __importStar(require("./utils"));
const errors_1 = require("./errors");
const defaulExpiration = {
    requestToken: 15,
    accessToken: 900,
};
class Session {
    constructor(appName = " ", privateKey = utils_1.randomKey(), tarProvider = "", didResolver, expiration = defaulExpiration) {
        this.privateKey = utils_1.privateKeyAsJWK(privateKey);
        this.appName = appName;
        this.tarProvider = tarProvider;
        this.didResolver = didResolver;
        this.expiration = expiration;
    }
    /*
     * Generate token
     */
    generateToken(opts) {
        const payload = {
            iss: this.appName,
            aud: this.appName,
            ...opts,
        };
        const token = jose_1.default.JWT.sign(payload, this.privateKey, {
            algorithm: "ES256K",
            header: {
                typ: "JWT",
            },
            expiresIn: `${this.expiration.accessToken} seconds`,
        });
        return {
            accessToken: token,
            tokenType: "Bearer",
            expiresIn: this.expiration.accessToken,
            issuedAt: Math.round(Date.now() / 1000),
        };
    }
    static checkBody(body) {
        if (body.grantType !== constants_1.GRANT_TYPE)
            throw new errors_1.BadRequestError(errors_1.BadRequestError.defaultTitle, {
                detail: `grantType must be '${constants_1.GRANT_TYPE}'`,
            });
        if (!body.assertion)
            throw new errors_1.BadRequestError(errors_1.BadRequestError.defaultTitle, {
                detail: "No assertion present in the body",
            });
        return body.scope;
    }
    async newSession(body, opts) {
        const scope = Session.checkBody(body);
        const token = body.assertion;
        const verifyOpts = {
            scope,
            audience: this.appName,
            expiration: this.expiration,
            tarProvider: this.tarProvider,
            didResolver: this.didResolver,
        };
        await utils.verify(token, verifyOpts);
        const sessionToken = this.generateToken(opts);
        return sessionToken;
    }
    verify(token) {
        try {
            // Check the signature
            const payload = jose_1.default.JWT.verify(token, this.privateKey);
            if (payload.aud !== this.appName)
                throw new Error(`Token with incorrect audience. Please create a new session with '${this.appName}'`);
        }
        catch (error) {
            throw new errors_1.InvalidTokenError(error.message);
        }
    }
}
exports.default = Session;
//# sourceMappingURL=session.js.map