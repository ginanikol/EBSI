"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.verify = exports.deduceScope = exports.decode = exports.checkHeadersPayload = exports.checkPayload = exports.checkHeaders = exports.randomKey = exports.privateKeyAsJWK = void 0;
const jose_1 = __importDefault(require("jose"));
const crypto_1 = __importDefault(require("crypto"));
const ethers_1 = require("ethers");
const did_jwt_1 = require("@cef-ebsi/did-jwt");
const constants_1 = require("./constants");
const trustedAppRegistry_1 = __importDefault(require("./trustedAppRegistry"));
const errors_1 = require("./errors");
const defaulExpiration = {
    requestToken: 15,
    accessToken: 900,
};
function hex2base64url(dataHex) {
    const buffer = Buffer.from(dataHex, "hex");
    const base64 = buffer.toString("base64");
    const base64url = base64
        .replace(/\+/g, "-")
        .replace(/\//g, "_")
        .replace(/=/g, "");
    return base64url;
}
function getJWKfromHex(_privKey) {
    let privKey = _privKey;
    if (!privKey.startsWith("0x"))
        privKey = `0x${privKey}`;
    const s = new ethers_1.ethers.utils.SigningKey(privKey);
    let pubKey = s.publicKey;
    // remove 0x and 0x04 to be used in jose library
    privKey = privKey.replace("0x", "");
    pubKey = pubKey.replace("0x04", "");
    return jose_1.default.JWK.asKey({
        crv: "secp256k1",
        kty: "EC",
        d: hex2base64url(privKey),
        x: hex2base64url(pubKey.substr(0, 64)),
        y: hex2base64url(pubKey.substr(64, 64)),
    });
}
function privateKeyAsJWK(privateKey) {
    if (typeof privateKey === "string") {
        if (privateKey.includes("BEGIN")) {
            // PEM Format
            return jose_1.default.JWK.asKey(privateKey);
        }
        // HEX Format
        return getJWKfromHex(privateKey);
    }
    return privateKey;
}
exports.privateKeyAsJWK = privateKeyAsJWK;
function randomKey(scope = constants_1.Scope.COMPONENT) {
    if (scope === constants_1.Scope.USER)
        return crypto_1.default.randomBytes(32).toString("hex");
    return jose_1.default.JWK.generateSync("EC", "secp256k1");
}
exports.randomKey = randomKey;
/*
 * Decode JSON Web Token
 */
function decode(token) {
    const jwtParts = token.split(".");
    let headers;
    let payload;
    try {
        headers = JSON.parse(Buffer.from(jwtParts[0], "base64").toString());
        payload = JSON.parse(Buffer.from(jwtParts[1], "base64").toString());
    }
    catch (error) {
        throw new errors_1.InvalidTokenError(`The token can not be parsed: ${error.message}`);
    }
    return { headers, payload };
}
exports.decode = decode;
/*
 * Function to deduce the scope based on the headers and payload
 */
function deduceScope(token) {
    let headers;
    let payload;
    if (typeof token === "string") {
        const decoded = decode(token);
        headers = decoded.headers;
        payload = decoded.payload;
    }
    else {
        headers = token.headers;
        payload = token.payload;
    }
    if (!headers || !payload)
        throw new errors_1.InvalidTokenError("Impossible to deduce scope: No headers or payload present");
    if (!payload.aud ||
        !payload.iss ||
        !payload.iat ||
        !payload.exp ||
        headers.typ !== "JWT") {
        throw new errors_1.InvalidTokenError("Impossible to deduce scope: Invalid headers or payload");
    }
    if (headers.alg === "ES256K" && payload.nonce)
        return constants_1.Scope.ENTITY;
    if (headers.alg === "ES256K")
        return constants_1.Scope.COMPONENT;
    if (headers.alg === "ES256K-R" && payload.ticket && payload.publicKey)
        return constants_1.Scope.USER;
    throw new errors_1.InvalidTokenError("Impossible to deduce scope: Invalid headers or payload");
}
exports.deduceScope = deduceScope;
/*
 * Function to check that headers are in accordance with EBSI standards
 */
function checkHeaders(headers, opts = {}) {
    const { scope } = opts;
    let algorithm = "ES256K";
    if (scope === constants_1.Scope.USER)
        algorithm = "ES256K-R";
    if (headers.alg !== algorithm)
        throw new errors_1.InvalidTokenError(`Since scope is '${scope}' the token algorithm must be '${algorithm}'. Received '${headers.alg}'`);
    if (headers.typ !== "JWT")
        throw new errors_1.InvalidTokenError("assertion has not typ=JWT in the header");
    return true;
}
exports.checkHeaders = checkHeaders;
/*
 * Function to check that payload is in accordance with EBSI standards
 */
function checkPayload(payload, opts = {}) {
    const { scope, audience } = opts;
    let { expiration } = opts;
    if (!expiration)
        expiration = defaulExpiration;
    if (!payload.aud || !payload.iss || !payload.iat || !payload.exp) {
        throw new errors_1.InvalidTokenError("The token requires iss, aud, iat, and exp in the payload");
    }
    const iat = payload.iat;
    const exp = payload.exp;
    if (exp - iat > expiration.requestToken)
        throw new errors_1.InvalidTokenError(`The expiration time can not exceed ${expiration.requestToken} seconds`);
    if (audience && payload.aud !== audience) {
        throw new errors_1.InvalidTokenError(`The aud in the token must be ${audience}`);
    }
    if (scope)
        switch (scope) {
            case constants_1.Scope.COMPONENT:
                break;
            case constants_1.Scope.ENTITY:
                if (!payload.nonce)
                    throw new errors_1.InvalidTokenError(`Since scope is '${constants_1.Scope.ENTITY}' the token requires a nonce in the payload`);
                break;
            case constants_1.Scope.USER:
                if (!payload.ticket || !payload.publicKey)
                    throw new errors_1.InvalidTokenError(`Since scope is '${constants_1.Scope.USER}' the token requires ticket and publicKey in the payload`);
                break;
            default:
                throw new errors_1.BadRequestError(errors_1.BadRequestError.defaultTitle, {
                    detail: `Invalid scope '${scope}'`,
                });
        }
    return true;
}
exports.checkPayload = checkPayload;
/*
 * Function to check that headers and payload are in accordance with EBSI standards
 */
function checkHeadersPayload(token, options = {}) {
    const { headers, payload } = decode(token);
    const opts = { ...options };
    if (!opts.scope)
        opts.scope = deduceScope({ headers, payload });
    checkHeaders(headers, opts);
    checkPayload(payload, opts);
    return { headers, payload, scope: opts.scope };
}
exports.checkHeadersPayload = checkHeadersPayload;
/*
 * Function to verify the authenticity of a token
 */
async function verify(token, opts = {}) {
    const { payload, scope } = checkHeadersPayload(token, opts);
    const appName = payload.aud;
    if (scope === constants_1.Scope.USER) {
        const optsVerify = {
            resolver: opts.didResolver,
            callbackUrl: appName,
        };
        try {
            await did_jwt_1.ebsiVerifyJwt(token, optsVerify);
        }
        catch (error) {
            const err = new errors_1.InvalidTokenError(error.message);
            err.stack = error.stack;
            throw err;
        }
    }
    else if (opts.tarProvider) {
        const authorizedAppName = payload.iss;
        const tar = new trustedAppRegistry_1.default(opts.tarProvider);
        await tar.verify(token);
        await tar.checkAuthorization(appName, authorizedAppName);
    }
}
exports.verify = verify;
//# sourceMappingURL=utils.js.map