import axios from "axios";
import type {
  DIDDocument,
  DIDResolutionOptions,
  DIDResolutionResult,
} from "did-resolver";
import { ProblemDetailsError } from "../errors.js";
import {
  DID_RESOLUTION_ERROR_CODES,
  type DidResolutionErrorCode,
} from "../constants.js";

const AXIOS_TIMEOUT = 15_000;

const SUPPORTED_CONTENT_TYPES = [
  "application/did+ld+json",
  "application/did+json",
] as const;
type ContentType = (typeof SUPPORTED_CONTENT_TYPES)[number];

function isSupportedContentType(
  contentType: string,
): contentType is ContentType {
  return SUPPORTED_CONTENT_TYPES.includes(contentType as ContentType);
}

async function get(
  url: string,
  contentType: ContentType,
  timeout: number,
): Promise<DIDDocument> {
  try {
    const response = await axios.get<DIDDocument>(url, {
      headers: {
        accept: contentType,
      },
      timeout: timeout || AXIOS_TIMEOUT,
    });
    return response.data;
  } catch (e) {
    let message = "";
    if (axios.isAxiosError(e)) {
      try {
        const { detail, title } = e.response?.data as ProblemDetailsError;
        message = detail || title;
      } catch (err) {
        message = e.message;
      }

      throw new ProblemDetailsError(
        e.response?.status || 500,
        e.response?.statusText || "",
        {
          detail: message,
        },
      );
    }

    throw e;
  }
}

export async function resolve(
  did: string,
  registry?: string,
  didResolutionOptions?: DIDResolutionOptions,
): Promise<DIDResolutionResult> {
  if (!registry) {
    return {
      didDocument: null,
      didDocumentMetadata: {},
      didResolutionMetadata: {
        error: DID_RESOLUTION_ERROR_CODES.CONFIGURATION_ERROR,
        message:
          "A DID registry must be defined in order to resolve EBSI DID method v1 documents",
      },
    };
  }

  let accept: ContentType = "application/did+ld+json";
  if (didResolutionOptions && didResolutionOptions.accept) {
    if (!isSupportedContentType(didResolutionOptions.accept)) {
      return {
        didDocument: null,
        didDocumentMetadata: {},
        didResolutionMetadata: {
          error: DID_RESOLUTION_ERROR_CODES.REPRESENTATION_NOT_SUPPORTED,
          message: `Representation ${
            didResolutionOptions.accept
          } is not supported. Valid representations include: ${SUPPORTED_CONTENT_TYPES.join(
            ", ",
          )}`,
        },
      };
    }

    accept = didResolutionOptions.accept;
  }

  // Resolve Legal Entity DID
  try {
    const timeout =
      didResolutionOptions &&
      typeof didResolutionOptions["timeout"] === "number"
        ? didResolutionOptions["timeout"]
        : AXIOS_TIMEOUT;

    const didDocument = await get(`${registry}/${did}`, accept, timeout);

    return {
      didDocument,
      didDocumentMetadata: {},
      didResolutionMetadata: { contentType: accept },
    };
  } catch (e) {
    let error: DidResolutionErrorCode =
      DID_RESOLUTION_ERROR_CODES.UNKNOWN_ERROR;
    let message = "";

    if (e instanceof ProblemDetailsError) {
      if (e.status === 400) {
        error = DID_RESOLUTION_ERROR_CODES.INVALID_DID;
        message = e.detail || e.title || "Bad Request";
      } else if (e.status === 404) {
        error = DID_RESOLUTION_ERROR_CODES.NOT_FOUND;
        message = e.detail || e.title || "Not Found";
      } else if (e.status === 500) {
        error = DID_RESOLUTION_ERROR_CODES.INTERNAL_SERVER_ERROR;
        message = e.detail || e.title || "Internal Server Error";
      } else {
        message = e.detail || e.title || "unknown";
      }
    } else if (e instanceof Error) {
      message = e.message;
    }

    return {
      didDocument: null,
      didDocumentMetadata: {},
      didResolutionMetadata: {
        error,
        message: `${message} | Registry used: ${registry}`,
      },
    };
  }
}
