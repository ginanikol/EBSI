"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.encode = exports.getPublicKeyJwk = exports.decryptSecp256k1 = exports.encryptSecp256k1 = void 0;
const utils_1 = require("@noble/hashes/utils");
const eciesjs_1 = require("eciesjs");
const elliptic_1 = __importDefault(require("elliptic"));
const key_encoder_1 = require("@cef-ebsi/key-encoder");
const basics_1 = require("multiformats/basics");
const { base64url } = basics_1.bases;
const EC = elliptic_1.default.ec;
const ec = new EC("secp256k1");
const keyEncoder = new key_encoder_1.KeyEncoder("secp256k1");
function encryptSecp256k1(payload, publicKeyHex) {
    const encrypted = (0, eciesjs_1.encrypt)(publicKeyHex, (0, utils_1.utf8ToBytes)(JSON.stringify(payload)));
    return (0, utils_1.bytesToHex)(encrypted);
}
exports.encryptSecp256k1 = encryptSecp256k1;
function decryptSecp256k1(privateKey, encrypted) {
    const decrypted = (0, eciesjs_1.decrypt)(privateKey, (0, utils_1.hexToBytes)(encrypted));
    return new TextDecoder().decode(decrypted);
}
exports.decryptSecp256k1 = decryptSecp256k1;
function getPublicKeyJwk(jwk, alg) {
    switch (alg) {
        case "ES256K":
        case "ES256":
        case "EdDSA": {
            const { d } = jwk, publicJwk = __rest(jwk, ["d"]);
            return publicJwk;
        }
        case "RS256": {
            const { d, p, q, dp, dq, qi } = jwk, publicJwk = __rest(jwk, ["d", "p", "q", "dp", "dq", "qi"]);
            return publicJwk;
        }
        default:
            throw new Error(`Algorithm ${alg} not supported`);
    }
}
exports.getPublicKeyJwk = getPublicKeyJwk;
exports.encode = {
    publicKey: {
        fromJWKToHex: (keyJwk) => {
            return ec
                .keyFromPublic({
                x: basics_1.bytes.toHex(base64url.baseDecode(keyJwk.x || "")),
                y: basics_1.bytes.toHex(base64url.baseDecode(keyJwk.y || "")),
            })
                .getPublic("hex");
        },
        fromHexToJWK: (keyHex) => {
            const pubPoint = ec.keyFromPublic(keyHex, "hex").getPublic();
            return {
                kty: "EC",
                crv: "secp256k1",
                x: base64url.baseEncode(pubPoint.getX().toBuffer("be", 32)),
                y: base64url.baseEncode(pubPoint.getY().toBuffer("be", 32)),
            };
        },
        fromJWKToPEM: (keyJwk) => {
            const keyHex = ec
                .keyFromPublic({
                x: basics_1.bytes.toHex(base64url.baseDecode(keyJwk.x || "")),
                y: basics_1.bytes.toHex(base64url.baseDecode(keyJwk.y || "")),
            })
                .getPublic("hex");
            return keyEncoder.encodePublic(keyHex, "raw", "pem");
        },
        get fromJWKtoHex() {
            return this.fromJWKToHex;
        },
        get fromHextoJWK() {
            return this.fromHexToJWK;
        },
        get fromJWKtoPEM() {
            return this.fromJWKToPEM;
        },
    },
    privateKey: {
        fromJWKToHex: (keyJwk) => {
            return basics_1.bytes.toHex(base64url.baseDecode(keyJwk.d || ""));
        },
        fromHexToJWK: (keyHex) => {
            const hex = keyHex.replace("0x", "");
            const pubPoint = ec.keyFromPrivate(hex, "hex").getPublic();
            return {
                kty: "EC",
                crv: "secp256k1",
                x: base64url.baseEncode(pubPoint.getX().toBuffer("be", 32)),
                y: base64url.baseEncode(pubPoint.getY().toBuffer("be", 32)),
                d: base64url.baseEncode(basics_1.bytes.fromHex(hex)),
            };
        },
        get fromJWKtoHex() {
            return this.fromJWKToHex;
        },
        get fromHextoJWK() {
            return this.fromHexToJWK;
        },
    },
};
//# sourceMappingURL=utils.js.map