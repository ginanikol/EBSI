"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyJwtDid = exports.verifyJwtTar = exports.getApp = exports.checkAuthorization = exports.getGenericName = exports.getErrorMessage = void 0;
const axios_1 = __importDefault(require("axios"));
const did_jwt_1 = require("did-jwt");
const key_encoder_1 = require("@cef-ebsi/key-encoder");
const basics_1 = require("multiformats/basics");
const did_resolver_1 = require("did-resolver");
const ebsi_did_resolver_1 = require("@cef-ebsi/ebsi-did-resolver");
const key_did_resolver_1 = require("@cef-ebsi/key-did-resolver");
const jose_1 = require("jose");
const utils_js_1 = require("./utils.js");
const { base16, base58btc, base64, base64url } = basics_1.bases;
const keyEncoder = new key_encoder_1.KeyEncoder("secp256k1");
const AXIOS_TIMEOUT = 15000;
function getErrorMessage(error) {
    var _a;
    if (!(error instanceof Error))
        return "unknown error";
    if (!axios_1.default.isAxiosError(error)) {
        return error.message;
    }
    if (typeof ((_a = error.response) === null || _a === void 0 ? void 0 : _a.data) !== "object")
        return error.message;
    const { data } = error.response;
    if (data.detail)
        return data.detail;
    if (data.title)
        return data.title;
    return JSON.stringify(data);
}
exports.getErrorMessage = getErrorMessage;
function getGenericName(appName) {
    const genericAppName = appName.split("_")[0];
    return genericAppName;
}
exports.getGenericName = getGenericName;
function checkAuthorization(resourceNodeApp, requesterNodeApp, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        const resourceApp = getGenericName(resourceNodeApp);
        const requesterApp = getGenericName(requesterNodeApp);
        try {
            let lastPage = Infinity;
            for (let page = 1; page <= lastPage; page += 1) {
                const urlParams = new URLSearchParams({
                    requesterApplicationName: requesterApp,
                    "page[after]": String(page),
                }).toString();
                const url = `${opts.trustedAppsRegistry}/${resourceApp}/authorizations?${urlParams}`;
                const { data: authPage } = yield axios_1.default.get(url, {
                    timeout: opts.timeout || AXIOS_TIMEOUT,
                });
                const { items, links } = authPage;
                if (lastPage === Infinity) {
                    const queryLastPage = links.last.substring(links.last.indexOf("?") + 1);
                    lastPage = Number(new URLSearchParams(queryLastPage).get("page[after]"));
                }
                const activeAuthorizations = yield Promise.all(items.map((authItem) => __awaiter(this, void 0, void 0, function* () {
                    const { data: authorization } = yield axios_1.default.get(authItem.href, {
                        timeout: opts.timeout || AXIOS_TIMEOUT,
                    });
                    return authorization.status === "active";
                })));
                if (activeAuthorizations.includes(true))
                    return;
            }
            throw new Error(`No active authorizations for resource ${resourceApp} and requester ${requesterApp}`);
        }
        catch (error) {
            throw new Error(getErrorMessage(error));
        }
    });
}
exports.checkAuthorization = checkAuthorization;
function getApp(kid, opts) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        let app;
        try {
            const response = yield axios_1.default.get(kid, { timeout: (_a = opts === null || opts === void 0 ? void 0 : opts.timeout) !== null && _a !== void 0 ? _a : AXIOS_TIMEOUT });
            app = response.data;
        }
        catch (error) {
            throw new Error(getErrorMessage(error));
        }
        if (app.revocation && Date.now() > app.revocation.notBefore * 1000) {
            throw new Error(`app ${app.name} revoked`);
        }
        return app;
    });
}
exports.getApp = getApp;
function verifyJwtTar(jwt, opts) {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function* () {
        const { header, payload } = (0, did_jwt_1.decodeJWT)(jwt);
        const { kid } = header;
        if (!kid || !kid.startsWith(opts.trustedAppsRegistry)) {
            throw new Error(`JWT with invalid kid. It should be hosted at ${opts.trustedAppsRegistry}`);
        }
        if (opts.audience &&
            getGenericName(payload.aud) !== opts.audience) {
            throw new Error(`JWT with invalid audience. Expected ${opts.audience}`);
        }
        const tApp = yield getApp(kid, { timeout: opts.timeout });
        if (!tApp.name || tApp.name !== payload.iss) {
            throw new Error(`kid resolves the app '${(_a = tApp.name) !== null && _a !== void 0 ? _a : ""}' but the iss field in the jwt refers to the app '${(_b = payload.iss) !== null && _b !== void 0 ? _b : ""}'`);
        }
        const validations = yield Promise.all(tApp.publicKeys.map((publicKeyPemBase64) => __awaiter(this, void 0, void 0, function* () {
            try {
                const publicKeyPem = basics_1.bytes.toString(base64.baseDecode(publicKeyPemBase64));
                const publicKeyHex = keyEncoder.encodePublic(publicKeyPem, "pem", "raw");
                const publicKeyJwk = utils_js_1.encode.publicKey.fromHexToJWK(publicKeyHex);
                const publicKey = yield (0, jose_1.importJWK)(publicKeyJwk, header.alg);
                const result = yield (0, jose_1.jwtVerify)(jwt, publicKey);
                return {
                    valid: true,
                    result,
                };
            }
            catch (error) {
                return {
                    valid: false,
                    error,
                };
            }
        })));
        const [valid] = validations.filter((v) => v.valid);
        if (!valid) {
            throw new Error(`JWT could not be validated with the public keys of '${tApp.name}'. Errors: ${JSON.stringify(validations.map((v) => v.error.message))}`);
        }
        if (opts.audience) {
            yield checkAuthorization(opts.audience, tApp.name, opts);
        }
        return valid.result;
    });
}
exports.verifyJwtTar = verifyJwtTar;
function verifyJwtDid(jwt, opts) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const { header } = (0, did_jwt_1.decodeJWT)(jwt);
        let { kid } = header;
        kid = kid.slice(kid.indexOf("/") + 1);
        const did = kid.split("#")[0];
        const resolver = new did_resolver_1.Resolver(Object.assign(Object.assign({}, (0, ebsi_did_resolver_1.getResolver)({
            registry: opts.didRegistry,
        })), (0, key_did_resolver_1.getResolver)()));
        const doc = yield resolver.resolve(did, {
            timeout: opts.timeout,
        });
        if (doc.didDocument === null) {
            throw new Error(`Unable to resolve ${did}. Error: ${doc.didResolutionMetadata.error || "unknown error"}. Message: ${((_a = doc.didResolutionMetadata) === null || _a === void 0 ? void 0 : _a["message"]) || "unknown details"}`);
        }
        const { didDocument } = doc;
        if (!didDocument || !didDocument.verificationMethod) {
            throw new Error(`DID document of ${did} must have verificationMethod`);
        }
        const verificationMethod = didDocument.verificationMethod.find((v) => v.id === kid);
        if (!verificationMethod) {
            throw new Error(`ID ${kid} not found in the list of verification methods`);
        }
        const { publicKeyJwk, publicKeyMultibase, publicKeyHex, publicKeyBase58 } = verificationMethod;
        let pubKeyJwk;
        if (publicKeyJwk) {
            pubKeyJwk = publicKeyJwk;
        }
        else if (publicKeyMultibase) {
            const baseDecoder = base16.decoder.or(base58btc.decoder.or(base64.decoder.or(base64url.decoder)));
            const pubKeyHex = basics_1.bytes.toHex(baseDecoder.decode(publicKeyMultibase));
            pubKeyJwk = utils_js_1.encode.publicKey.fromHexToJWK(pubKeyHex);
        }
        else if (publicKeyHex) {
            pubKeyJwk = utils_js_1.encode.publicKey.fromHexToJWK(publicKeyHex);
        }
        else if (publicKeyBase58) {
            const pubKeyHex = basics_1.bytes.toHex(base58btc.baseDecode(publicKeyBase58));
            pubKeyJwk = utils_js_1.encode.publicKey.fromHexToJWK(pubKeyHex);
        }
        else {
            throw new Error(`The ID ${kid} does not contain a valid public key`);
        }
        const publicKey = yield (0, jose_1.importJWK)(pubKeyJwk, header.alg);
        return {
            result: yield (0, jose_1.jwtVerify)(jwt, publicKey),
            didDocument,
        };
    });
}
exports.verifyJwtDid = verifyJwtDid;
//# sourceMappingURL=verifier.js.map