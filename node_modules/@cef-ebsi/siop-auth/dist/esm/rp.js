var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _RP_privateKey;
import { decodeJWT } from "did-jwt";
import { EncryptJWT, importJWK, SignJWT } from "jose";
import { bases, bytes } from "multiformats/basics";
import { v4 as uuidv4 } from "uuid";
import { URLSearchParams } from "node:url";
import { expiration } from "./constants.js";
import { encryptSecp256k1, encode } from "./utils.js";
const { base64url } = bases;
const allowedSelfIssuers = [
    "https://self-issued.me",
    "https://self-issued.me/v2",
];
export class RP {
    constructor(opts = {}) {
        _RP_privateKey.set(this, void 0);
        __classPrivateFieldSet(this, _RP_privateKey, opts.privateKey ?? new Uint8Array(), "f");
        this.alg = opts.alg ?? "";
        this.kid = opts.kid ?? "";
        this.name = opts.name ?? "";
        this.redirectUri = opts.redirectUri ?? "";
    }
    async createRequest(requestPayload) {
        const payload = {
            scope: "openid did_authn",
            response_type: "id_token",
            response_mode: "post",
            client_id: this.redirectUri,
            redirect_uri: this.redirectUri,
            nonce: uuidv4(),
            ...requestPayload,
        };
        const jwt = await new SignJWT(payload)
            .setProtectedHeader({
            alg: this.alg,
            typ: "JWT",
            kid: this.kid,
        })
            .setIssuedAt()
            .setIssuer(this.name)
            .setExpirationTime(expiration.request)
            .sign(__classPrivateFieldGet(this, _RP_privateKey, "f"));
        const urlParams = new URLSearchParams({
            response_type: payload.response_type,
            client_id: payload.redirect_uri,
            scope: payload.scope,
            nonce: payload.nonce,
            request: jwt,
        });
        return `openid://?${urlParams.toString()}`;
    }
    static async verifyResponse(jwt, processClaims) {
        const { payload, header } = decodeJWT(jwt);
        if (!allowedSelfIssuers.includes(payload.iss))
            throw new Error(`invalid issuer ${payload.iss ?? ""}. Possible values: ${allowedSelfIssuers.join(", ")}`);
        if (!payload.nonce)
            throw new Error("No nonce found in JWT payload");
        const { claims } = payload;
        const resultClaims = await processClaims(claims);
        return {
            payload: {
                did: resultClaims.did,
                ...payload,
            },
            header,
            resultClaims,
        };
    }
    async createAccessToken(resultVerification, payloadToken) {
        const { did, encryption_key: encryptionKeyJwk } = resultVerification.resultClaims;
        const { nonce } = resultVerification.payload;
        const { alg } = resultVerification.header;
        const payloadAccessToken = {
            sub: did,
            did,
            aud: "ebsi-core-services",
            nonce: uuidv4(),
            login_hint: "did_siop",
            ...payloadToken,
        };
        const accessToken = await new SignJWT(payloadAccessToken)
            .setProtectedHeader({
            alg: this.alg,
            typ: "JWT",
            kid: this.kid,
        })
            .setIssuedAt()
            .setIssuer(this.name)
            .setExpirationTime(expiration.accessToken)
            .sign(__classPrivateFieldGet(this, _RP_privateKey, "f"));
        const payloadEncryption = {
            access_token: accessToken,
            kid: this.kid,
            nonce,
        };
        let encryptedAccessToken;
        if (alg === "ES256K") {
            const encryptionKeyHex = encode.publicKey.fromJWKToHex(encryptionKeyJwk);
            encryptedAccessToken = encryptSecp256k1(payloadEncryption, encryptionKeyHex);
        }
        else {
            const encryptionKey = await importJWK(encryptionKeyJwk, alg);
            encryptedAccessToken = await new EncryptJWT(payloadEncryption)
                .setProtectedHeader({
                alg: alg === "RS256" ? "RSA1_5" : "ECDH-ES",
                enc: "A128GCM",
            })
                .encrypt(encryptionKey);
        }
        const ake1Sig = await new SignJWT({
            ake1_nonce: nonce,
            ake1_enc_payload: encryptedAccessToken,
            did,
        })
            .setProtectedHeader({
            alg: this.alg,
            typ: "JWT",
            kid: this.kid,
        })
            .setIssuedAt()
            .setIssuer(this.name)
            .setExpirationTime(expiration.accessToken)
            .sign(__classPrivateFieldGet(this, _RP_privateKey, "f"));
        const ake1SigPayloadBase64url = ake1Sig.split(".")[1];
        const ake1SigPayload = JSON.parse(bytes.toString(base64url.baseDecode(ake1SigPayloadBase64url)));
        const ake1JwsDetached = ake1Sig.replace(ake1SigPayloadBase64url, "");
        return {
            ake1_enc_payload: encryptedAccessToken,
            ake1_sig_payload: ake1SigPayload,
            ake1_jws_detached: ake1JwsDetached,
            kid: this.kid,
        };
    }
}
_RP_privateKey = new WeakMap();
//# sourceMappingURL=rp.js.map