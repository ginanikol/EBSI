import { hexToBytes, utf8ToBytes, bytesToHex } from "@noble/hashes/utils";
import { encrypt as eciesEncrypt, decrypt as eciesDecrypt } from "eciesjs";
import elliptic from "elliptic";
import { KeyEncoder } from "@cef-ebsi/key-encoder";
import { bases, bytes } from "multiformats/basics";
const { base64url } = bases;
const EC = elliptic.ec;
const ec = new EC("secp256k1");
const keyEncoder = new KeyEncoder("secp256k1");
export function encryptSecp256k1(payload, publicKeyHex) {
    const encrypted = eciesEncrypt(publicKeyHex, utf8ToBytes(JSON.stringify(payload)));
    return bytesToHex(encrypted);
}
export function decryptSecp256k1(privateKey, encrypted) {
    const decrypted = eciesDecrypt(privateKey, hexToBytes(encrypted));
    return new TextDecoder().decode(decrypted);
}
export function getPublicKeyJwk(jwk, alg) {
    switch (alg) {
        case "ES256K":
        case "ES256":
        case "EdDSA": {
            const { d, ...publicJwk } = jwk;
            return publicJwk;
        }
        case "RS256": {
            const { d, p, q, dp, dq, qi, ...publicJwk } = jwk;
            return publicJwk;
        }
        default:
            throw new Error(`Algorithm ${alg} not supported`);
    }
}
export const encode = {
    publicKey: {
        fromJWKToHex: (keyJwk) => {
            return ec
                .keyFromPublic({
                x: bytes.toHex(base64url.baseDecode(keyJwk.x || "")),
                y: bytes.toHex(base64url.baseDecode(keyJwk.y || "")),
            })
                .getPublic("hex");
        },
        fromHexToJWK: (keyHex) => {
            const pubPoint = ec.keyFromPublic(keyHex, "hex").getPublic();
            return {
                kty: "EC",
                crv: "secp256k1",
                x: base64url.baseEncode(pubPoint.getX().toBuffer("be", 32)),
                y: base64url.baseEncode(pubPoint.getY().toBuffer("be", 32)),
            };
        },
        fromJWKToPEM: (keyJwk) => {
            const keyHex = ec
                .keyFromPublic({
                x: bytes.toHex(base64url.baseDecode(keyJwk.x || "")),
                y: bytes.toHex(base64url.baseDecode(keyJwk.y || "")),
            })
                .getPublic("hex");
            return keyEncoder.encodePublic(keyHex, "raw", "pem");
        },
        get fromJWKtoHex() {
            return this.fromJWKToHex;
        },
        get fromHextoJWK() {
            return this.fromHexToJWK;
        },
        get fromJWKtoPEM() {
            return this.fromJWKToPEM;
        },
    },
    privateKey: {
        fromJWKToHex: (keyJwk) => {
            return bytes.toHex(base64url.baseDecode(keyJwk.d || ""));
        },
        fromHexToJWK: (keyHex) => {
            const hex = keyHex.replace("0x", "");
            const pubPoint = ec.keyFromPrivate(hex, "hex").getPublic();
            return {
                kty: "EC",
                crv: "secp256k1",
                x: base64url.baseEncode(pubPoint.getX().toBuffer("be", 32)),
                y: base64url.baseEncode(pubPoint.getY().toBuffer("be", 32)),
                d: base64url.baseEncode(bytes.fromHex(hex)),
            };
        },
        get fromJWKtoHex() {
            return this.fromJWKToHex;
        },
        get fromHextoJWK() {
            return this.fromHexToJWK;
        },
    },
};
//# sourceMappingURL=utils.js.map