import { JWK } from "jose";
import { hexToBytes, utf8ToBytes, bytesToHex } from "@noble/hashes/utils";
import { encrypt as eciesEncrypt, decrypt as eciesDecrypt } from "eciesjs";
import elliptic from "elliptic";
import { KeyEncoder } from "@cef-ebsi/key-encoder";
import { bases, bytes } from "multiformats/basics";

const { base64url } = bases;
const EC = elliptic.ec;
const ec = new EC("secp256k1");
const keyEncoder = new KeyEncoder("secp256k1");

export function encryptSecp256k1(
  payload: { [x: string]: unknown },
  publicKeyHex: string,
): string {
  const encrypted = eciesEncrypt(
    publicKeyHex,
    utf8ToBytes(JSON.stringify(payload)),
  );

  return bytesToHex(encrypted);
}

export function decryptSecp256k1(
  privateKey: string,
  encrypted: string,
): string {
  const decrypted = eciesDecrypt(privateKey, hexToBytes(encrypted));

  return new TextDecoder().decode(decrypted);
}

export function getPublicKeyJwk(jwk: JWK, alg: string): JWK {
  switch (alg) {
    case "ES256K":
    case "ES256":
    case "EdDSA": {
      const { d, ...publicJwk } = jwk;
      return publicJwk;
    }
    case "RS256": {
      const { d, p, q, dp, dq, qi, ...publicJwk } = jwk;
      return publicJwk;
    }
    default:
      throw new Error(`Algorithm ${alg} not supported`);
  }
}

export const encode = {
  publicKey: {
    fromJWKToHex: (keyJwk: JWK): string => {
      return ec
        .keyFromPublic({
          x: bytes.toHex(base64url.baseDecode(keyJwk.x || "")),
          y: bytes.toHex(base64url.baseDecode(keyJwk.y || "")),
        })
        .getPublic("hex");
    },

    fromHexToJWK: (keyHex: string): JWK => {
      const pubPoint = ec.keyFromPublic(keyHex, "hex").getPublic();
      return {
        kty: "EC",
        crv: "secp256k1",
        x: base64url.baseEncode(pubPoint.getX().toBuffer("be", 32)),
        y: base64url.baseEncode(pubPoint.getY().toBuffer("be", 32)),
      };
    },

    fromJWKToPEM: (keyJwk: JWK): string => {
      const keyHex = ec
        .keyFromPublic({
          x: bytes.toHex(base64url.baseDecode(keyJwk.x || "")),
          y: bytes.toHex(base64url.baseDecode(keyJwk.y || "")),
        })
        .getPublic("hex");
      return keyEncoder.encodePublic(keyHex, "raw", "pem");
    },

    // Aliases for deprecated functions names (backward compatibility)
    /**
     * @deprecated Use fromJWKToHex instead
     */
    get fromJWKtoHex() {
      return this.fromJWKToHex;
    },

    /**
     * @deprecated Use fromHexToJWK instead
     */
    get fromHextoJWK() {
      return this.fromHexToJWK;
    },

    /**
     * @deprecated Use fromJWKToPEM instead
     */
    get fromJWKtoPEM() {
      return this.fromJWKToPEM;
    },
  },
  privateKey: {
    fromJWKToHex: (keyJwk: JWK): string => {
      return bytes.toHex(base64url.baseDecode(keyJwk.d || ""));
    },

    fromHexToJWK: (keyHex: string): JWK => {
      const hex = keyHex.replace("0x", "");
      const pubPoint = ec.keyFromPrivate(hex, "hex").getPublic();
      return {
        kty: "EC",
        crv: "secp256k1",
        x: base64url.baseEncode(pubPoint.getX().toBuffer("be", 32)),
        y: base64url.baseEncode(pubPoint.getY().toBuffer("be", 32)),
        d: base64url.baseEncode(bytes.fromHex(hex)),
      };
    },

    // Aliases for deprecated functions names (backward compatibility)

    /**
     * @deprecated Use fromJWKToHex instead
     */
    get fromJWKtoHex() {
      return this.fromJWKToHex;
    },

    /**
     * @deprecated Use fromHexToJWK instead
     */
    get fromHextoJWK() {
      return this.fromHexToJWK;
    },
  },
};
