import { decodeJWT, JWTHeader } from "did-jwt";
import { EncryptJWT, importJWK, KeyLike, SignJWT } from "jose";
import { bases, bytes } from "multiformats/basics";
import { v4 as uuidv4 } from "uuid";
import { URLSearchParams } from "node:url";
import { expiration } from "./constants.js";
import type {
  RequestPayload,
  Ake1SigPayload,
  ResponseClaims,
  VerifyResponseResult,
  JWTPayloadEbsi,
  ResultProcessClaims,
} from "./types.js";
import { encryptSecp256k1, encode } from "./utils.js";

const { base64url } = bases;

const allowedSelfIssuers = [
  "https://self-issued.me",
  "https://self-issued.me/v2",
];

export class RP {
  #privateKey: KeyLike | Uint8Array;

  alg: string;

  name: string;

  kid: string;

  redirectUri: string;

  constructor(
    opts: {
      privateKey?: KeyLike | Uint8Array;
      alg?: string;
      name?: string;
      kid?: string;
      redirectUri?: string;
      didRegistry?: string;
    } = {},
  ) {
    this.#privateKey = opts.privateKey ?? new Uint8Array();
    this.alg = opts.alg ?? "";
    this.kid = opts.kid ?? "";
    this.name = opts.name ?? "";
    this.redirectUri = opts.redirectUri ?? "";
  }

  async createRequest(requestPayload: RequestPayload): Promise<string> {
    const payload = {
      scope: "openid did_authn",
      response_type: "id_token",
      response_mode: "post",
      client_id: this.redirectUri,
      redirect_uri: this.redirectUri,
      nonce: uuidv4(),
      ...requestPayload,
    };

    const jwt = await new SignJWT(payload)
      .setProtectedHeader({
        alg: this.alg,
        typ: "JWT",
        kid: this.kid,
      })
      .setIssuedAt()
      .setIssuer(this.name)
      .setExpirationTime(expiration.request)
      .sign(this.#privateKey);

    const urlParams = new URLSearchParams({
      response_type: payload.response_type,
      client_id: payload.redirect_uri,
      scope: payload.scope,
      nonce: payload.nonce,
      request: jwt,
    });

    return `openid://?${urlParams.toString()}`;
  }

  static async verifyResponse(
    jwt: string,
    processClaims: (claims?: ResponseClaims) => Promise<ResultProcessClaims>,
  ): Promise<VerifyResponseResult> {
    const { payload, header } = decodeJWT(jwt) as unknown as {
      header: JWTHeader;
      payload: JWTPayloadEbsi;
    };
    if (!allowedSelfIssuers.includes(payload.iss as string))
      throw new Error(
        `invalid issuer ${
          payload.iss ?? ""
        }. Possible values: ${allowedSelfIssuers.join(", ")}`,
      );

    if (!payload.nonce) throw new Error("No nonce found in JWT payload");

    const { claims } = payload;

    const resultClaims = await processClaims(claims);

    return {
      payload: {
        did: resultClaims.did,
        ...payload,
      },
      header,
      resultClaims,
    };
  }

  async createAccessToken(
    resultVerification: VerifyResponseResult,
    payloadToken?: { [x: string]: unknown },
  ) {
    const { did, encryption_key: encryptionKeyJwk } =
      resultVerification.resultClaims;
    const { nonce } = resultVerification.payload;
    const { alg } = resultVerification.header;

    const payloadAccessToken = {
      sub: did,
      did,
      aud: "ebsi-core-services",
      nonce: uuidv4(),
      login_hint: "did_siop",
      ...payloadToken,
    };

    const accessToken = await new SignJWT(payloadAccessToken)
      .setProtectedHeader({
        alg: this.alg,
        typ: "JWT",
        kid: this.kid,
      })
      .setIssuedAt()
      .setIssuer(this.name)
      .setExpirationTime(expiration.accessToken)
      .sign(this.#privateKey);

    const payloadEncryption = {
      access_token: accessToken,
      kid: this.kid,
      nonce,
    };

    let encryptedAccessToken: string;

    if (alg === "ES256K") {
      const encryptionKeyHex = encode.publicKey.fromJWKToHex(encryptionKeyJwk);
      encryptedAccessToken = encryptSecp256k1(
        payloadEncryption,
        encryptionKeyHex,
      );
    } else {
      const encryptionKey = await importJWK(encryptionKeyJwk, alg);
      encryptedAccessToken = await new EncryptJWT(payloadEncryption)
        .setProtectedHeader({
          alg: alg === "RS256" ? "RSA1_5" : "ECDH-ES",
          enc: "A128GCM",
        })
        .encrypt(encryptionKey);
    }

    const ake1Sig = await new SignJWT({
      ake1_nonce: nonce,
      ake1_enc_payload: encryptedAccessToken,
      did,
    })
      .setProtectedHeader({
        alg: this.alg,
        typ: "JWT",
        kid: this.kid,
      })
      .setIssuedAt()
      .setIssuer(this.name)
      .setExpirationTime(expiration.accessToken)
      .sign(this.#privateKey);

    const ake1SigPayloadBase64url = ake1Sig.split(".")[1]!;
    const ake1SigPayload = JSON.parse(
      bytes.toString(base64url.baseDecode(ake1SigPayloadBase64url)),
    ) as Ake1SigPayload;
    const ake1JwsDetached = ake1Sig.replace(ake1SigPayloadBase64url, "");

    return {
      ake1_enc_payload: encryptedAccessToken,
      ake1_sig_payload: ake1SigPayload,
      ake1_jws_detached: ake1JwsDetached,
      kid: this.kid,
    };
  }
}
