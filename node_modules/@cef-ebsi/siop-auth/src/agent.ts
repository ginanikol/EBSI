import {
  calculateJwkThumbprint,
  exportJWK,
  importJWK,
  JWK,
  jwtDecrypt,
  KeyLike,
  SignJWT,
} from "jose";
import { validate } from "@cef-ebsi/ebsi-did-resolver";
import { KEY_DID_METHOD_PREFIX } from "@cef-ebsi/key-did-resolver";
import type {
  AkeResponse,
  UriResponse,
  ResponsePayload,
  CreateResponseOptions,
} from "./types.js";
import { decryptSecp256k1, encode, getPublicKeyJwk } from "./utils.js";
import { expiration } from "./constants.js";
import { verifyJwtTar } from "./verifier.js";

export class Agent {
  #privateKey: KeyLike | Uint8Array;

  kid: string;

  did: string;

  alg: string;

  siopV2: boolean;

  isDidV2: boolean;

  constructor(
    opts: {
      privateKey?: KeyLike | Uint8Array;
      alg?: string;
      kid?: string;
      siopV2?: boolean;
    } = {},
  ) {
    this.#privateKey = opts.privateKey ?? new Uint8Array();
    this.alg = opts.alg ?? "";
    this.kid = opts.kid ?? "";
    this.did = this.kid.slice(0, this.kid.indexOf("#"));
    this.siopV2 = opts.siopV2 ?? true;
    this.isDidV2 =
      this.did.startsWith(KEY_DID_METHOD_PREFIX) || validate(this.did) === 2;
  }

  async createResponse(
    responsePayload: ResponsePayload,
    options: CreateResponseOptions = {},
  ): Promise<UriResponse> {
    const { responseMode = "fragment", syntaxType = "jwk_thumbprint_subject" } =
      options;
    const { redirectUri, ...extraPayload } = responsePayload;

    const privateKeyJwk = await exportJWK(this.#privateKey);
    const publicKeyJwk = getPublicKeyJwk(privateKeyJwk, this.alg);

    const payload = {
      aud: redirectUri,
      ...(syntaxType === "jwk_thumbprint_subject" && {
        sub: await calculateJwkThumbprint(publicKeyJwk),
        sub_jwk: publicKeyJwk,
      }),
      ...(syntaxType === "did_subject" && { sub: this.did }),
      ...(!this.siopV2 && { did: this.did }),
      ...extraPayload,
    };

    const issuer = this.siopV2
      ? "https://self-issued.me/v2"
      : "https://self-issued.me";
    const jwt = await new SignJWT(payload)
      .setProtectedHeader({
        alg: this.alg,
        typ: "JWT",
        kid: this.kid,
        ...(this.isDidV2 &&
          syntaxType === "did_subject" && { jwk: publicKeyJwk }),
      })
      .setIssuedAt()
      .setIssuer(issuer)
      .setExpirationTime(expiration.response)
      .sign(this.#privateKey);

    const urlParams = new URLSearchParams({
      id_token: jwt,
    }).toString();

    switch (responseMode) {
      case "post":
      case "form_post":
        return {
          encoding: "application/x-www-form-urlencoded",
          urlEncoded: encodeURI(redirectUri),
          responseMode,
          bodyEncoded: urlParams,
          idToken: jwt,
        };
      case "query":
        return {
          encoding: "application/x-www-form-urlencoded",
          urlEncoded: encodeURI(`${redirectUri}?${urlParams}`),
          responseMode,
          idToken: jwt,
        };
      case "fragment":
        return {
          encoding: "application/x-www-form-urlencoded",
          urlEncoded: encodeURI(`${redirectUri}#${urlParams}`),
          responseMode,
          idToken: jwt,
        };
      default:
        throw new Error("invalid response mode");
    }
  }

  static async verifyAkeResponse(
    response: AkeResponse,
    opts: {
      nonce: string;
      privateEncryptionKeyJwk: JWK;
      trustedAppsRegistry: string;
      alg: string;
      audience?: string;
      timeout?: number;
    },
  ): Promise<string> {
    const { ake1_enc_payload: ake1EncPayload } = response;
    let ake1DecPayload: {
      kid: string;
      access_token: string;
      nonce: string;
    };
    if (opts.alg === "ES256K") {
      const privateEncryptionKeyHex = encode.privateKey.fromJWKToHex(
        opts.privateEncryptionKeyJwk,
      );
      ake1DecPayload = JSON.parse(
        decryptSecp256k1(privateEncryptionKeyHex, ake1EncPayload),
      ) as {
        kid: string;
        access_token: string;
        nonce: string;
      };
    } else {
      const privateEncryptionKey = await importJWK(
        opts.privateEncryptionKeyJwk,
        opts.alg,
      );
      ake1DecPayload = (await jwtDecrypt(ake1EncPayload, privateEncryptionKey))
        .payload as {
        kid: string;
        access_token: string;
        nonce: string;
      };
    }

    const { kid, nonce, access_token: accessToken } = ake1DecPayload;

    if (
      typeof kid !== "string" ||
      typeof accessToken !== "string" ||
      typeof nonce !== "string"
    ) {
      throw new Error(
        `invalid decrypted payload. Received: ${JSON.stringify(
          ake1DecPayload,
        )}`,
      );
    }

    if (nonce !== opts.nonce) {
      throw new Error(`Expected nonce ${opts.nonce}. Received ${nonce}`);
    }

    await verifyJwtTar(accessToken, {
      trustedAppsRegistry: opts.trustedAppsRegistry,
      audience: opts.audience || "ebsi-core-services",
      timeout: opts.timeout,
    });

    return accessToken;
  }
}
