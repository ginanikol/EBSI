import axios from "axios";
import { decodeJWT } from "did-jwt";
import { KeyEncoder } from "@cef-ebsi/key-encoder";
import { bases, bytes } from "multiformats/basics";
import { Resolver } from "did-resolver";
import type { DIDDocument, JsonWebKey } from "did-resolver";
import { getResolver as getEbsiDidResolver } from "@cef-ebsi/ebsi-did-resolver";
import { getResolver as getKeyDidResolver } from "@cef-ebsi/key-did-resolver";
import { importJWK, JWK, jwtVerify, JWTVerifyResult } from "jose";
import { encode } from "./utils.js";
import type { AuthPage, AuthorizationResponseObject } from "./types.js";

const { base16, base58btc, base64, base64url } = bases;
const keyEncoder = new KeyEncoder("secp256k1");

const AXIOS_TIMEOUT = 15000;

export function getErrorMessage(error: unknown) {
  if (!(error instanceof Error)) return "unknown error";

  if (!axios.isAxiosError(error)) {
    return error.message;
  }

  if (typeof error.response?.data !== "object") return error.message;

  const { data } = error.response as {
    data: { title: string; detail: string };
  };

  if (data.detail) return data.detail;

  if (data.title) return data.title;

  return JSON.stringify(data);
}

export function getGenericName(appName: string) {
  const genericAppName = appName.split("_")[0]!;
  return genericAppName;
}

export async function checkAuthorization(
  resourceNodeApp: string,
  requesterNodeApp: string,
  opts: {
    trustedAppsRegistry: string;
    timeout?: number;
  },
): Promise<void> {
  const resourceApp = getGenericName(resourceNodeApp);
  const requesterApp = getGenericName(requesterNodeApp);

  try {
    let lastPage = Infinity;

    /* eslint-disable no-await-in-loop */
    for (let page = 1; page <= lastPage; page += 1) {
      const urlParams = new URLSearchParams({
        requesterApplicationName: requesterApp,
        "page[after]": String(page),
      }).toString();
      const url = `${opts.trustedAppsRegistry}/${resourceApp}/authorizations?${urlParams}`;
      const { data: authPage } = await axios.get<AuthPage>(url, {
        timeout: opts.timeout || AXIOS_TIMEOUT,
      });

      const { items, links } = authPage;

      if (lastPage === Infinity) {
        const queryLastPage = links.last.substring(links.last.indexOf("?") + 1);
        lastPage = Number(
          new URLSearchParams(queryLastPage).get("page[after]"),
        );
      }

      const activeAuthorizations = await Promise.all(
        items.map(async (authItem) => {
          const { data: authorization } =
            await axios.get<AuthorizationResponseObject>(authItem.href, {
              timeout: opts.timeout || AXIOS_TIMEOUT,
            });

          return authorization.status === "active";
        }),
      );

      // check if at least 1 authorization is active
      if (activeAuthorizations.includes(true)) return;
    }
    /* eslint-enable no-await-in-loop */

    throw new Error(
      `No active authorizations for resource ${resourceApp} and requester ${requesterApp}`,
    );
  } catch (error) {
    throw new Error(getErrorMessage(error));
  }
}

export async function getApp(
  kid: string,
  opts?: {
    timeout?: number;
  },
): Promise<{
  name: string;
  publicKeys: string[];
  revocation: {
    revokedBy: string;
    notBefore: number;
  } | null;
}> {
  let app: {
    name: string;
    publicKeys: string[];
    revocation: {
      revokedBy: string;
      notBefore: number;
    } | null;
  };
  try {
    const response = await axios.get<{
      name: string;
      publicKeys: string[];
      revocation: {
        revokedBy: string;
        notBefore: number;
      } | null;
    }>(kid, { timeout: opts?.timeout ?? AXIOS_TIMEOUT });
    app = response.data;
  } catch (error) {
    throw new Error(getErrorMessage(error));
  }

  if (app.revocation && Date.now() > app.revocation.notBefore * 1000) {
    throw new Error(`app ${app.name} revoked`);
  }

  return app;
}

export async function verifyJwtTar(
  jwt: string,
  opts: {
    trustedAppsRegistry: string;
    audience?: string;
    timeout?: number;
  },
): Promise<JWTVerifyResult> {
  const { header, payload } = decodeJWT(jwt);
  const { kid } = header as unknown as { kid: string };
  if (!kid || !kid.startsWith(opts.trustedAppsRegistry)) {
    throw new Error(
      `JWT with invalid kid. It should be hosted at ${opts.trustedAppsRegistry}`,
    );
  }

  if (
    opts.audience &&
    getGenericName(payload.aud as string) !== opts.audience
  ) {
    throw new Error(`JWT with invalid audience. Expected ${opts.audience}`);
  }

  const tApp = await getApp(kid, { timeout: opts.timeout });

  if (!tApp.name || tApp.name !== payload.iss) {
    throw new Error(
      `kid resolves the app '${
        tApp.name ?? ""
      }' but the iss field in the jwt refers to the app '${payload.iss ?? ""}'`,
    );
  }

  const validations = await Promise.all(
    tApp.publicKeys.map(async (publicKeyPemBase64: string) => {
      try {
        const publicKeyPem = bytes.toString(
          base64.baseDecode(publicKeyPemBase64),
        );
        const publicKeyHex = keyEncoder.encodePublic(
          publicKeyPem,
          "pem",
          "raw",
        );
        const publicKeyJwk = encode.publicKey.fromHexToJWK(publicKeyHex);
        const publicKey = await importJWK(publicKeyJwk, header.alg);
        const result = await jwtVerify(jwt, publicKey);
        return {
          valid: true,
          result,
        };
      } catch (error) {
        return {
          valid: false,
          error,
        };
      }
    }),
  );

  const [valid] = validations.filter((v) => v.valid);
  if (!valid) {
    throw new Error(
      `JWT could not be validated with the public keys of '${
        tApp.name
      }'. Errors: ${JSON.stringify(
        validations.map((v) => (v.error as Error).message),
      )}`,
    );
  }

  if (opts.audience) {
    await checkAuthorization(opts.audience, tApp.name, opts);
  }

  return valid.result as JWTVerifyResult;
}

export async function verifyJwtDid(
  jwt: string,
  opts: {
    didRegistry?: string;
    timeout?: number;
  },
): Promise<{
  result: JWTVerifyResult;
  didDocument: DIDDocument;
}> {
  const { header } = decodeJWT(jwt) as unknown as {
    header: { kid: string; jwk: JsonWebKey; alg: string };
  };
  let { kid } = header;
  kid = kid.slice(kid.indexOf("/") + 1);
  const did = kid.split("#")[0]!;

  const resolver = new Resolver({
    ...getEbsiDidResolver({
      registry: opts.didRegistry,
    }),
    ...getKeyDidResolver(),
  });

  const doc = await resolver.resolve(did, {
    timeout: opts.timeout,
  });

  if (doc.didDocument === null) {
    throw new Error(
      `Unable to resolve ${did}. Error: ${
        doc.didResolutionMetadata.error || "unknown error"
      }. Message: ${
        (doc.didResolutionMetadata?.["message"] as string) || "unknown details"
      }`,
    );
  }
  const { didDocument } = doc;

  if (!didDocument || !didDocument.verificationMethod) {
    throw new Error(`DID document of ${did} must have verificationMethod`);
  }

  const verificationMethod = didDocument.verificationMethod.find(
    (v) => v.id === kid,
  );

  if (!verificationMethod) {
    throw new Error(`ID ${kid} not found in the list of verification methods`);
  }

  const { publicKeyJwk, publicKeyMultibase, publicKeyHex, publicKeyBase58 } =
    verificationMethod;

  let pubKeyJwk: JWK;

  if (publicKeyJwk) {
    pubKeyJwk = publicKeyJwk;
  } else if (publicKeyMultibase) {
    // Supports base16, base58btc, base64 and base64url multibase encoded public keys
    const baseDecoder = base16.decoder.or(
      base58btc.decoder.or(base64.decoder.or(base64url.decoder)),
    );
    const pubKeyHex = bytes.toHex(baseDecoder.decode(publicKeyMultibase));
    pubKeyJwk = encode.publicKey.fromHexToJWK(pubKeyHex);
  } else if (publicKeyHex) {
    pubKeyJwk = encode.publicKey.fromHexToJWK(publicKeyHex);
  } else if (publicKeyBase58) {
    const pubKeyHex = bytes.toHex(base58btc.baseDecode(publicKeyBase58));
    pubKeyJwk = encode.publicKey.fromHexToJWK(pubKeyHex);
  } else {
    throw new Error(`The ID ${kid} does not contain a valid public key`);
  }

  const publicKey = await importJWK(pubKeyJwk, header.alg);
  return {
    result: await jwtVerify(jwt, publicKey),
    didDocument,
  };
}
