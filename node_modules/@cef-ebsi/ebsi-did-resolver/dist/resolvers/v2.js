"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolve = void 0;
const jose_1 = require("jose");
const base58_1 = require("multiformats/bases/base58");
const base64_1 = require("multiformats/bases/base64");
const constants_1 = require("../constants");
const SUPPORTED_CONTENT_TYPES = [
    "application/did+ld+json",
    "application/did+json",
];
function isSupportedContentType(contentType) {
    return SUPPORTED_CONTENT_TYPES.includes(contentType);
}
async function resolve(did, naturalPersonJwks, didResolutionOptions) {
    if (!naturalPersonJwks ||
        !Array.isArray(naturalPersonJwks) ||
        naturalPersonJwks.length === 0) {
        return {
            didDocument: null,
            didDocumentMetadata: {},
            didResolutionMetadata: {
                error: constants_1.DID_RESOLUTION_ERROR_CODES.CONFIGURATION_ERROR,
                message: "At least 1 JWK must be shared in order to resolve EBSI DID method v2 documents",
            },
        };
    }
    let accept = "application/did+ld+json";
    if (didResolutionOptions && didResolutionOptions.accept) {
        if (!isSupportedContentType(didResolutionOptions.accept)) {
            return {
                didDocument: null,
                didDocumentMetadata: {},
                didResolutionMetadata: {
                    error: constants_1.DID_RESOLUTION_ERROR_CODES.REPRESENTATION_NOT_SUPPORTED,
                    message: `Representation ${didResolutionOptions.accept} is not supported. Valid representations include: ${SUPPORTED_CONTENT_TYPES.join(", ")}`,
                },
            };
        }
        accept = didResolutionOptions.accept;
    }
    // Resolve Natural Person DID
    try {
        const matchingJwk = (await Promise.all(naturalPersonJwks.map(async (jwk) => {
            const thumbprint = await (0, jose_1.calculateJwkThumbprint)(jwk, "sha256");
            const bytesArray = new Uint8Array(1 + constants_1.EBSI_DID_SPECS.NATURAL_PERSON.BYTE_LENGTH);
            bytesArray.set([constants_1.EBSI_DID_SPECS.NATURAL_PERSON.VERSION_ID]);
            bytesArray.set(base64_1.base64url.baseDecode(thumbprint), 1);
            const methodSpecificIdentifier = base58_1.base58btc.encode(bytesArray);
            if (did === `${constants_1.EBSI_DID_METHOD_PREFIX}${methodSpecificIdentifier}`) {
                return { jwk, thumbprint };
            }
            return null;
        }))).filter((res) => res !== null);
        if (matchingJwk.length === 0) {
            return {
                didDocument: null,
                didDocumentMetadata: {},
                didResolutionMetadata: {
                    error: constants_1.DID_RESOLUTION_ERROR_CODES.NOT_FOUND,
                    message: `Could not find a JWK matching the DID "${did}"`,
                },
            };
        }
        const { jwk: publicKeyJwk, thumbprint } = matchingJwk[0];
        return {
            didDocument: {
                ...(accept === "application/did+ld+json" && {
                    "@context": [
                        "https://www.w3.org/ns/did/v1",
                        "https://w3id.org/security/suites/jws-2020/v1",
                    ],
                }),
                id: did,
                verificationMethod: [
                    {
                        id: `${did}#${thumbprint}`,
                        type: "JsonWebKey2020",
                        controller: did,
                        publicKeyJwk: {
                            ...publicKeyJwk,
                            // As recommended by https://www.w3.org/TR/did-core/#dfn-publickeyjwk
                            // "It is RECOMMENDED that JWK kid values are set to the public key fingerprint"
                            kid: thumbprint,
                        },
                    },
                ],
                authentication: [`${did}#${thumbprint}`],
                assertionMethod: [`${did}#${thumbprint}`],
            },
            didDocumentMetadata: {},
            didResolutionMetadata: { contentType: accept },
        };
    }
    catch (e) {
        const errorMessage = e instanceof Error ? e.message : "unknown";
        return {
            didDocument: null,
            didDocumentMetadata: {},
            didResolutionMetadata: {
                error: constants_1.DID_RESOLUTION_ERROR_CODES.INVALID_JWK,
                message: `One of the provided JWKs is invalid. Error message: ${errorMessage}`,
            },
        };
    }
}
exports.resolve = resolve;
exports.default = resolve;
//# sourceMappingURL=v2.js.map