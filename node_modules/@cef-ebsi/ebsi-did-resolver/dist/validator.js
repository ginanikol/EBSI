"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validate = void 0;
const base58_1 = require("multiformats/bases/base58");
const constants_1 = require("./constants");
/**
 * Verifies if the DID follows the EBSI DID method v1 or v2 specs.
 *
 * @param did - The DID to verify
 * @returns The version number associated with the DID
 */
function validate(did) {
    if (!did || typeof did !== "string") {
        throw new Error("The DID must be a string");
    }
    if (!did.startsWith(constants_1.EBSI_DID_METHOD_PREFIX)) {
        throw new Error(`The DID must start with "${constants_1.EBSI_DID_METHOD_PREFIX}"`);
    }
    const methodSpecificIdentifier = did.substring(constants_1.EBSI_DID_METHOD_PREFIX.length);
    if (!methodSpecificIdentifier.startsWith("z")) {
        throw new Error('The method-specific identifier must start with "z" (multibase base58btc-encoded)');
    }
    let decodedIdentifier;
    try {
        decodedIdentifier = base58_1.base58btc.decode(methodSpecificIdentifier);
    }
    catch (e) {
        throw new Error("The method-specific identifier is not a valid multibase base58btc-encoded string");
    }
    const version = decodedIdentifier[0];
    const didSpecsKey = constants_1.SUPPORTED_VERSIONS.find((specKey) => version === constants_1.EBSI_DID_SPECS[specKey].VERSION_ID);
    if (!didSpecsKey) {
        throw new Error(`Unsupported version "${version}"`);
    }
    if (decodedIdentifier.byteLength - 1 !==
        constants_1.EBSI_DID_SPECS[didSpecsKey].BYTE_LENGTH) {
        throw new Error(`The subject identifier length (${decodedIdentifier.byteLength - 1} bytes) does not match the expected length (${constants_1.EBSI_DID_SPECS[didSpecsKey].BYTE_LENGTH} bytes)`);
    }
    return version;
}
exports.validate = validate;
exports.default = validate;
//# sourceMappingURL=validator.js.map