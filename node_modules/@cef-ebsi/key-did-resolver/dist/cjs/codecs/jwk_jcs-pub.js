"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decode = exports.encode = exports.code = exports.name = void 0;
const lodash_isplainobject_1 = __importDefault(require("lodash.isplainobject"));
exports.name = "jwk_jcs-pub";
exports.code = 0xeb51;
const textEncoder = new TextEncoder();
const textDecoder = new TextDecoder();
function check(value, description) {
    if (typeof value !== "string" || !value) {
        throw new Error(`${description} missing or invalid`);
    }
}
function validatePlainObject(value) {
    if (!(0, lodash_isplainobject_1.default)(value)) {
        throw new Error("JWK must be an object");
    }
}
function validateJwk(jwk) {
    validatePlainObject(jwk);
    switch (jwk["kty"]) {
        case "EC":
            check(jwk["crv"], '"crv" (Curve) Parameter');
            check(jwk["x"], '"x" (X Coordinate) Parameter');
            check(jwk["y"], '"y" (Y Coordinate) Parameter');
            break;
        case "OKP":
            check(jwk["crv"], '"crv" (Subtype of Key Pair) Parameter');
            check(jwk["x"], '"x" (Public Key) Parameter');
            break;
        case "RSA":
            check(jwk["e"], '"e" (Exponent) Parameter');
            check(jwk["n"], '"n" (Modulus) Parameter');
            break;
        default:
            throw new Error('"kty" (Key Type) Parameter missing or unsupported');
    }
}
function canonicaliseJwk(jwk) {
    let components;
    switch (jwk.kty) {
        case "EC":
            components = { crv: jwk.crv, kty: jwk.kty, x: jwk.x, y: jwk.y };
            break;
        case "OKP":
            components = { crv: jwk.crv, kty: jwk.kty, x: jwk.x };
            break;
        case "RSA":
            components = { e: jwk.e, kty: jwk.kty, n: jwk.n };
            break;
    }
    return components;
}
function encode(jwk) {
    validateJwk(jwk);
    const components = canonicaliseJwk(jwk);
    return textEncoder.encode(JSON.stringify(components));
}
exports.encode = encode;
function decode(bytes) {
    const jwk = JSON.parse(textDecoder.decode(bytes));
    validateJwk(jwk);
    if (JSON.stringify(jwk) !== JSON.stringify(canonicaliseJwk(jwk))) {
        throw new Error("The JWK embedded in the DID is not correctly formatted");
    }
    return jwk;
}
exports.decode = decode;
//# sourceMappingURL=jwk_jcs-pub.js.map