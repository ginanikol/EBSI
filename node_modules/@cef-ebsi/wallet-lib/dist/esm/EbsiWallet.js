var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _EbsiWallet_privateKey;
import { keccak_256 } from "@noble/hashes/sha3";
import { bytesToHex, randomBytes } from "@noble/hashes/utils";
import elliptic from "elliptic";
import { KeyEncoder } from "@cef-ebsi/key-encoder";
import { Buffer } from "buffer";
import { createJWT, ES256KSigner } from "did-jwt";
import { EBSI_DID_SPECS, util as ebsiDidResolverUtil, } from "@cef-ebsi/ebsi-did-resolver";
import { util as keyDidResolverUtil } from "@cef-ebsi/key-did-resolver";
import { remove0xPrefix, hexStringToBase64Url } from "./utils.js";
const EC = elliptic.ec;
const LEGAL_ENTITY = "LEGAL_ENTITY";
const NATURAL_PERSON = "NATURAL_PERSON";
const SUPPORTED_VERSIONS = ["LEGAL_ENTITY", "NATURAL_PERSON"];
export class EbsiWallet {
    constructor(privateKey) {
        _EbsiWallet_privateKey.set(this, void 0);
        if (typeof privateKey === "string") {
            __classPrivateFieldSet(this, _EbsiWallet_privateKey, Buffer.from(remove0xPrefix(privateKey), "hex"), "f");
        }
        else {
            __classPrivateFieldSet(this, _EbsiWallet_privateKey, privateKey, "f");
        }
    }
    static createDid(version = LEGAL_ENTITY, publicKeyJwk) {
        if (version === NATURAL_PERSON) {
            return keyDidResolverUtil.createDid(publicKeyJwk);
        }
        return ebsiDidResolverUtil.createDid(randomBytes(EBSI_DID_SPECS[version].BYTE_LENGTH));
    }
    static formatPublicKey(publicKey, format = "hex") {
        if (format === "hex") {
            return publicKey.encode("hex", false);
        }
        if (format === "pem") {
            const keyEncoder = new KeyEncoder("secp256k1");
            const rawPublicKey = publicKey.encode("hex", false);
            const pemPublicKey = keyEncoder.encodePublic(rawPublicKey, "raw", "pem");
            return pemPublicKey;
        }
        const jwk = {
            kty: "EC",
            crv: "secp256k1",
            x: hexStringToBase64Url(publicKey.getX().toString("hex", 64)),
            y: hexStringToBase64Url(publicKey.getY().toString("hex", 64)),
        };
        return jwk;
    }
    static formatPrivateKey(privateKey, format = "hex") {
        const privateKeyHex = privateKey.toString("hex", 64);
        if (format === "hex") {
            return privateKeyHex;
        }
        if (format === "pem") {
            const keyEncoder = new KeyEncoder("secp256k1");
            const pemPrivateKey = keyEncoder.encodePrivate(privateKeyHex, "raw", "pem");
            return pemPrivateKey;
        }
        const publicKey = EbsiWallet.ec.keyFromPrivate(privateKeyHex).getPublic();
        const jwk = {
            kty: "EC",
            crv: "secp256k1",
            x: hexStringToBase64Url(publicKey.getX().toString("hex", 64)),
            y: hexStringToBase64Url(publicKey.getY().toString("hex", 64)),
            d: hexStringToBase64Url(privateKeyHex),
        };
        return jwk;
    }
    static generateKeyPair({ format = "hex", } = {}) {
        const outputKeyOptions = {
            format,
            keyType: "EC",
            keyCurve: "secp256k1",
        };
        const keyPair = EbsiWallet.ec.genKeyPair();
        const publicKey = keyPair.getPublic();
        const privateKey = keyPair.getPrivate();
        keyPair.getPublic();
        return {
            keyOptions: outputKeyOptions,
            publicKey: EbsiWallet.formatPublicKey(publicKey, format),
            privateKey: EbsiWallet.formatPrivateKey(privateKey, format),
        };
    }
    getPublicKey({ format } = {}) {
        const key = EbsiWallet.ec.keyFromPrivate(__classPrivateFieldGet(this, _EbsiWallet_privateKey, "f"));
        const publicKey = key.getPublic();
        return EbsiWallet.formatPublicKey(publicKey, format);
    }
    getEthereumAddress() {
        const publicKey = this.getPublicKey({ format: "hex" });
        return bytesToHex(keccak_256(Buffer.from(publicKey.slice(2), "hex"))).slice(-40);
    }
    static async prepareEthereumTransaction(txRequest, provider) {
        const { from, to, data, value } = txRequest;
        const gasEstimation = await provider.estimateGas({ from, to, data, value });
        return {
            ...txRequest,
            gasLimit: gasEstimation.mul(14).div(10),
        };
    }
    async signJwt(payload, options, header) {
        const signer = ES256KSigner(__classPrivateFieldGet(this, _EbsiWallet_privateKey, "f"));
        const signedJwt = await createJWT(payload, {
            signer,
            issuer: options.issuer,
            expiresIn: options.expiresIn,
            canonicalize: true,
        }, header);
        return signedJwt;
    }
}
_EbsiWallet_privateKey = new WeakMap();
EbsiWallet.ec = new EC("secp256k1");
//# sourceMappingURL=EbsiWallet.js.map