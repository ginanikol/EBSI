"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _EbsiWallet_privateKey;
Object.defineProperty(exports, "__esModule", { value: true });
exports.EbsiWallet = void 0;
const sha3_1 = require("@noble/hashes/sha3");
const utils_1 = require("@noble/hashes/utils");
const elliptic_1 = __importDefault(require("elliptic"));
const key_encoder_1 = require("@cef-ebsi/key-encoder");
const buffer_1 = require("buffer");
const did_jwt_1 = require("did-jwt");
const ebsi_did_resolver_1 = require("@cef-ebsi/ebsi-did-resolver");
const key_did_resolver_1 = require("@cef-ebsi/key-did-resolver");
const utils_js_1 = require("./utils.js");
const EC = elliptic_1.default.ec;
const LEGAL_ENTITY = "LEGAL_ENTITY";
const NATURAL_PERSON = "NATURAL_PERSON";
const SUPPORTED_VERSIONS = ["LEGAL_ENTITY", "NATURAL_PERSON"];
class EbsiWallet {
    constructor(privateKey) {
        _EbsiWallet_privateKey.set(this, void 0);
        if (typeof privateKey === "string") {
            __classPrivateFieldSet(this, _EbsiWallet_privateKey, buffer_1.Buffer.from((0, utils_js_1.remove0xPrefix)(privateKey), "hex"), "f");
        }
        else {
            __classPrivateFieldSet(this, _EbsiWallet_privateKey, privateKey, "f");
        }
    }
    static createDid(version = LEGAL_ENTITY, publicKeyJwk) {
        if (version === NATURAL_PERSON) {
            return key_did_resolver_1.util.createDid(publicKeyJwk);
        }
        return ebsi_did_resolver_1.util.createDid((0, utils_1.randomBytes)(ebsi_did_resolver_1.EBSI_DID_SPECS[version].BYTE_LENGTH));
    }
    static formatPublicKey(publicKey, format = "hex") {
        if (format === "hex") {
            return publicKey.encode("hex", false);
        }
        if (format === "pem") {
            const keyEncoder = new key_encoder_1.KeyEncoder("secp256k1");
            const rawPublicKey = publicKey.encode("hex", false);
            const pemPublicKey = keyEncoder.encodePublic(rawPublicKey, "raw", "pem");
            return pemPublicKey;
        }
        const jwk = {
            kty: "EC",
            crv: "secp256k1",
            x: (0, utils_js_1.hexStringToBase64Url)(publicKey.getX().toString("hex", 64)),
            y: (0, utils_js_1.hexStringToBase64Url)(publicKey.getY().toString("hex", 64)),
        };
        return jwk;
    }
    static formatPrivateKey(privateKey, format = "hex") {
        const privateKeyHex = privateKey.toString("hex", 64);
        if (format === "hex") {
            return privateKeyHex;
        }
        if (format === "pem") {
            const keyEncoder = new key_encoder_1.KeyEncoder("secp256k1");
            const pemPrivateKey = keyEncoder.encodePrivate(privateKeyHex, "raw", "pem");
            return pemPrivateKey;
        }
        const publicKey = EbsiWallet.ec.keyFromPrivate(privateKeyHex).getPublic();
        const jwk = {
            kty: "EC",
            crv: "secp256k1",
            x: (0, utils_js_1.hexStringToBase64Url)(publicKey.getX().toString("hex", 64)),
            y: (0, utils_js_1.hexStringToBase64Url)(publicKey.getY().toString("hex", 64)),
            d: (0, utils_js_1.hexStringToBase64Url)(privateKeyHex),
        };
        return jwk;
    }
    static generateKeyPair({ format = "hex", } = {}) {
        const outputKeyOptions = {
            format,
            keyType: "EC",
            keyCurve: "secp256k1",
        };
        const keyPair = EbsiWallet.ec.genKeyPair();
        const publicKey = keyPair.getPublic();
        const privateKey = keyPair.getPrivate();
        keyPair.getPublic();
        return {
            keyOptions: outputKeyOptions,
            publicKey: EbsiWallet.formatPublicKey(publicKey, format),
            privateKey: EbsiWallet.formatPrivateKey(privateKey, format),
        };
    }
    getPublicKey({ format } = {}) {
        const key = EbsiWallet.ec.keyFromPrivate(__classPrivateFieldGet(this, _EbsiWallet_privateKey, "f"));
        const publicKey = key.getPublic();
        return EbsiWallet.formatPublicKey(publicKey, format);
    }
    getEthereumAddress() {
        const publicKey = this.getPublicKey({ format: "hex" });
        return (0, utils_1.bytesToHex)((0, sha3_1.keccak_256)(buffer_1.Buffer.from(publicKey.slice(2), "hex"))).slice(-40);
    }
    static prepareEthereumTransaction(txRequest, provider) {
        return __awaiter(this, void 0, void 0, function* () {
            const { from, to, data, value } = txRequest;
            const gasEstimation = yield provider.estimateGas({ from, to, data, value });
            return Object.assign(Object.assign({}, txRequest), { gasLimit: gasEstimation.mul(14).div(10) });
        });
    }
    signJwt(payload, options, header) {
        return __awaiter(this, void 0, void 0, function* () {
            const signer = (0, did_jwt_1.ES256KSigner)(__classPrivateFieldGet(this, _EbsiWallet_privateKey, "f"));
            const signedJwt = yield (0, did_jwt_1.createJWT)(payload, {
                signer,
                issuer: options.issuer,
                expiresIn: options.expiresIn,
                canonicalize: true,
            }, header);
            return signedJwt;
        });
    }
}
exports.EbsiWallet = EbsiWallet;
_EbsiWallet_privateKey = new WeakMap();
EbsiWallet.ec = new EC("secp256k1");
//# sourceMappingURL=EbsiWallet.js.map