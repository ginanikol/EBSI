import { base58btc } from "multiformats/bases/base58";
import {
  EBSI_DID_METHOD_PREFIX,
  EBSI_DID_SPECS,
  SUPPORTED_VERSIONS,
} from "./constants.js";

/**
 * Verifies if the DID follows the EBSI DID method v1.
 *
 * @param did - The DID to verify
 * @returns The version number associated with the DID
 */
export function validate(did: string): number {
  if (!did || typeof did !== "string") {
    throw new Error("The DID must be a string");
  }

  if (!did.startsWith(EBSI_DID_METHOD_PREFIX)) {
    throw new Error(`The DID must start with "${EBSI_DID_METHOD_PREFIX}"`);
  }

  const methodSpecificIdentifier = did.substring(EBSI_DID_METHOD_PREFIX.length);

  if (!methodSpecificIdentifier.startsWith("z")) {
    throw new Error(
      'The method-specific identifier must start with "z" (multibase base58btc-encoded)',
    );
  }

  let decodedIdentifier: Uint8Array;
  try {
    decodedIdentifier = base58btc.decode(methodSpecificIdentifier);
  } catch (e) {
    throw new Error(
      "The method-specific identifier is not a valid multibase base58btc-encoded string",
    );
  }

  const version = decodedIdentifier[0];

  if (!version) {
    throw new Error("No version found");
  }

  const didSpecsKey = SUPPORTED_VERSIONS.find(
    (specKey) => version === EBSI_DID_SPECS[specKey].VERSION_ID,
  );

  if (!didSpecsKey) {
    throw new Error(`Unsupported version "${version}"`);
  }

  if (
    decodedIdentifier.byteLength - 1 !==
    EBSI_DID_SPECS[didSpecsKey].BYTE_LENGTH
  ) {
    throw new Error(
      `The subject identifier length (${
        decodedIdentifier.byteLength - 1
      } bytes) does not match the expected length (${
        EBSI_DID_SPECS[didSpecsKey].BYTE_LENGTH
      } bytes)`,
    );
  }

  return version;
}
