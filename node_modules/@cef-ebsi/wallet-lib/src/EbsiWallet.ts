import type BN from "bn.js";
import type { curve } from "elliptic";
import type { TransactionRequest, Provider } from "@ethersproject/providers";
import { keccak_256 } from "@noble/hashes/sha3";
import { bytesToHex, randomBytes } from "@noble/hashes/utils";
import elliptic from "elliptic";
import { KeyEncoder } from "@cef-ebsi/key-encoder";
import { Buffer } from "buffer";
import { createJWT, ES256KSigner, JWTHeader } from "did-jwt";
import {
  EBSI_DID_SPECS,
  util as ebsiDidResolverUtil,
} from "@cef-ebsi/ebsi-did-resolver";
import { util as keyDidResolverUtil } from "@cef-ebsi/key-did-resolver";
import type { JWK } from "jose";
import type {
  EBSIJWKECKey,
  EBSIJWKEllipticCurve,
  EBSIJWKType,
  EBSIKeyFormat,
} from "./types.js";
import { remove0xPrefix, hexStringToBase64Url } from "./utils.js";

const EC = elliptic.ec;

const LEGAL_ENTITY = "LEGAL_ENTITY";
const NATURAL_PERSON = "NATURAL_PERSON";
const SUPPORTED_VERSIONS = ["LEGAL_ENTITY", "NATURAL_PERSON"] as const;

export interface KeyOptions {
  format?: EBSIKeyFormat;
  keyType?: EBSIJWKType;
  keyCurve?: EBSIJWKEllipticCurve;
}

export interface KeyPair<
  T extends string | EBSIJWKECKey = string | EBSIJWKECKey,
> {
  keyOptions: KeyOptions;
  publicKey: T;
  privateKey: T;
}

/**
 * EbsiWallet class
 */
export class EbsiWallet {
  /**
   * The 32 bytes private key encoded in hexadecimal and prefixed with 0x.
   */
  #privateKey: Uint8Array;

  static ec = new EC("secp256k1");

  /**
   * @param privateKey - A raw 32 bytes private key encoded in hexadecimal
   *
   * @example
   * ```ts
   * const privateKey = "0a9a229c18f1777949243bbe875b754b77fb9cb3612c8b5c37876888f54f9731";
   * const wallet = new EbsiWallet(privateKey);
   * ```
   */
  constructor(privateKey: string | Uint8Array) {
    // TODO: validate input
    // is hex? is 32 bytes long?
    if (typeof privateKey === "string") {
      this.#privateKey = Buffer.from(remove0xPrefix(privateKey), "hex");
    } else {
      this.#privateKey = privateKey;
    }
  }

  /**
   * Creates a new EBSI DID.
   *
   * @param version - "LEGAL_ENTITY" (default) or "NATURAL_PERSON"
   * @param subjectIdentifierBytes - Subject identifier used to construct a Natural Person DID
   * @returns An EBSI DID, e.g. "did:ebsi:zsSgDXeYPhZ3AuKhTFneDf1"
   *
   * @example
   * ```ts
   * // Create a random Legal Entity DID
   * const did = EbsiWallet.createDid();
   *
   * // Create a random Legal Entity DID (same as `EbsiWallet.createDid()`)
   * const did = EbsiWallet.createDid("LEGAL_ENTITY");
   *
   * // Create a random Natural Person DID (not recommended)
   * const did = EbsiWallet.createDid("NATURAL_PERSON");
   *
   * // Create Natural Person DID with subject identifier
   * import { calculateJwkThumbprint, exportJWK, generateKeyPair } from "jose";
   * import { base64url } from "multiformats/bases/base64";
   *
   * const { publicKey } = await generateKeyPair("ES256K");
   * const jwk = await exportJWK(publicKey);
   * const thumbprint = await calculateJwkThumbprint(jwk, "sha256");
   * const subjectIdentifier = base64url.baseDecode(thumbprint);
   * const did = EbsiWallet.createDid("NATURAL_PERSON", subjectIdentifier);
   * ```
   */
  static createDid(version?: typeof LEGAL_ENTITY): string;
  static createDid(version: typeof NATURAL_PERSON, publicKeyJwk: JWK): string;
  static createDid(
    version: (typeof SUPPORTED_VERSIONS)[number] = LEGAL_ENTITY,
    publicKeyJwk?: JWK,
  ): string {
    // For Natural Persons, use @cef-ebsi/ebsinp-did-resolver
    if (version === NATURAL_PERSON) {
      return keyDidResolverUtil.createDid(publicKeyJwk as JWK);
    }

    // Return radom Legal Entity DID
    return ebsiDidResolverUtil.createDid(
      randomBytes(EBSI_DID_SPECS[version].BYTE_LENGTH),
    );
  }

  /**
   * Transforms the public key to the specified format.
   *
   * @param publicKey - A secp256k1 EC public key
   * @param format - Desired output format ("hex", "pem" or "jwk")
   * @returns The formatted public key
   */
  static formatPublicKey(
    publicKey: curve.base.BasePoint,
    format?: "pem" | "hex",
  ): string;
  static formatPublicKey(
    publicKey: curve.base.BasePoint,
    format: "jwk",
  ): EBSIJWKECKey;
  static formatPublicKey(
    publicKey: curve.base.BasePoint,
    format?: EBSIKeyFormat,
  ): string | EBSIJWKECKey;
  static formatPublicKey(
    publicKey: curve.base.BasePoint,
    format: EBSIKeyFormat = "hex",
  ): string | EBSIJWKECKey {
    if (format === "hex") {
      return publicKey.encode("hex", false);
    }

    if (format === "pem") {
      const keyEncoder = new KeyEncoder("secp256k1");
      const rawPublicKey = publicKey.encode("hex", false);
      const pemPublicKey = keyEncoder.encodePublic(rawPublicKey, "raw", "pem");

      return pemPublicKey;
    }

    const jwk: EBSIJWKECKey = {
      kty: "EC",
      crv: "secp256k1",
      x: hexStringToBase64Url(publicKey.getX().toString("hex", 64)),
      y: hexStringToBase64Url(publicKey.getY().toString("hex", 64)),
    };

    return jwk;
  }

  /**
   * Transforms the private key to the specified format.
   *
   * @param privateKey - A secp256k1 EC private key
   * @param format - Desired output format ("hex", "pem" or "jwk")
   * @returns The formatted private key
   */
  static formatPrivateKey(privateKey: BN, format?: "pem" | "hex"): string;
  static formatPrivateKey(privateKey: BN, format: "jwk"): EBSIJWKECKey;
  static formatPrivateKey(
    privateKey: BN,
    format?: EBSIKeyFormat,
  ): string | EBSIJWKECKey;
  static formatPrivateKey(
    privateKey: BN,
    format: EBSIKeyFormat = "hex",
  ): string | EBSIJWKECKey {
    const privateKeyHex = privateKey.toString("hex", 64);

    if (format === "hex") {
      return privateKeyHex;
    }

    if (format === "pem") {
      const keyEncoder = new KeyEncoder("secp256k1");
      const pemPrivateKey = keyEncoder.encodePrivate(
        privateKeyHex,
        "raw",
        "pem",
      );

      return pemPrivateKey;
    }

    const publicKey = EbsiWallet.ec.keyFromPrivate(privateKeyHex).getPublic();

    const jwk: EBSIJWKECKey = {
      kty: "EC",
      crv: "secp256k1",
      x: hexStringToBase64Url(publicKey.getX().toString("hex", 64)),
      y: hexStringToBase64Url(publicKey.getY().toString("hex", 64)),
      d: hexStringToBase64Url(privateKeyHex),
    };

    return jwk;
  }

  /**
   * Generates a new random ES256K key pair
   *
   * @param keyOptions - Format options
   * @returns A new key pair
   */
  static generateKeyPair(opts?: { format?: "hex" | "pem" }): KeyPair<string>;
  static generateKeyPair(opts: { format: "jwk" }): KeyPair<EBSIJWKECKey>;
  static generateKeyPair({
    format = "hex",
  }: { format?: EBSIKeyFormat } = {}): KeyPair {
    const outputKeyOptions: KeyOptions = {
      format,
      keyType: "EC",
      keyCurve: "secp256k1",
    };

    const keyPair = EbsiWallet.ec.genKeyPair();
    const publicKey = keyPair.getPublic();
    const privateKey = keyPair.getPrivate();

    keyPair.getPublic();

    return {
      keyOptions: outputKeyOptions,
      publicKey: EbsiWallet.formatPublicKey(publicKey, format),
      privateKey: EbsiWallet.formatPrivateKey(privateKey, format),
    };
  }

  /**
   * Gets the public key from the wallet private key.
   *
   * @param keyOptions - Format options
   * @returns The public key
   */
  getPublicKey(opts?: { format?: "hex" | "pem" }): string;
  getPublicKey(opts: { format: "jwk" }): EBSIJWKECKey;
  getPublicKey({ format }: { format?: EBSIKeyFormat } = {}):
    | string
    | EBSIJWKECKey {
    const key = EbsiWallet.ec.keyFromPrivate(this.#privateKey);
    const publicKey = key.getPublic();
    return EbsiWallet.formatPublicKey(publicKey, format);
  }

  /**
   * Gets the Ethereum address from the wallet private key.
   *
   * @returns The Ethereum address
   */
  getEthereumAddress(): string {
    const publicKey = this.getPublicKey({ format: "hex" });
    return bytesToHex(keccak_256(Buffer.from(publicKey.slice(2), "hex"))).slice(
      -40,
    );
  }

  /**
   *
   * @param txRequest - The transaction for which we want to estimate the gas required
   * @param provider - An ethers.js Provider
   * @returns A transaction object with an estimated gas limit
   */
  static async prepareEthereumTransaction(
    txRequest: TransactionRequest,
    provider: Provider,
  ): Promise<TransactionRequest> {
    const { from, to, data, value } = txRequest;

    const gasEstimation = await provider.estimateGas({ from, to, data, value });

    return {
      ...txRequest,
      // Multiply by 1.4
      gasLimit: gasEstimation.mul(14).div(10),
    };
  }

  /**
   * Create a JWT signed with the wallet private key.
   *
   * @param payload - JSON payload
   * @param options - Signing options
   * @param header - Optional header fields
   * @returns Signed JWT
   */
  async signJwt(
    payload: { [x: string]: unknown },
    options: { issuer: string; expiresIn?: number },
    header?: Partial<JWTHeader>,
  ): Promise<string> {
    const signer = ES256KSigner(this.#privateKey);

    const signedJwt = await createJWT(
      payload,
      {
        signer,
        issuer: options.issuer,
        expiresIn: options.expiresIn,
        canonicalize: true,
      },
      header,
    );

    return signedJwt;
  }
}
