"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const elliptic_1 = require("elliptic");
const crypto_1 = require("../crypto");
const util_1 = __importDefault(require("./util"));
const RecoverableES256K_1 = __importDefault(require("./RecoverableES256K"));
const secp256k1 = new elliptic_1.ec("secp256k1");
class ES256KVerifier {
    constructor() {
        this.algoName = "ES256K-R";
    }
    verify(data, signature, authenticators) {
        const hash = crypto_1.sha256(data);
        const sigObj = util_1.default(signature);
        const fullPublicKeys = authenticators.filter(({ publicKeyHex }) => {
            return typeof publicKeyHex !== "undefined";
        });
        const ethAddressKeys = authenticators.filter(({ ethereumAddress }) => {
            return typeof ethereumAddress !== "undefined";
        });
        let signer = fullPublicKeys.find(({ publicKeyHex }) => {
            try {
                if (!publicKeyHex)
                    throw new Error("No public key found!");
                return secp256k1
                    .keyFromPublic(publicKeyHex, "hex")
                    .verify(hash, sigObj);
            }
            catch (err) {
                return false;
            }
        });
        if (!signer && ethAddressKeys.length > 0) {
            signer = new RecoverableES256K_1.default().verify(data, signature, ethAddressKeys);
        }
        if (!signer)
            throw new Error(`Signature ${this.algoName} invalid for JWT`);
        return signer;
    }
}
exports.default = ES256KVerifier;
//# sourceMappingURL=ES256KVerifier.js.map