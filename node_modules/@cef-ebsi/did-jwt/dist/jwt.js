"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyJwt = exports.verifyJWS = exports.ebsiVerifyJwt = exports.createJwt = exports.decodeJwt = exports.normalizeDID = void 0;
const base64url_1 = __importDefault(require("base64url"));
const VerifierAlgorithm_1 = __importDefault(require("./VerifierAlgorithm"));
const SignerAlgorithm_1 = __importDefault(require("./SignerAlgorithm"));
const types_1 = require("./types");
const resolveAuthenticator_1 = __importDefault(require("./resolveAuthenticator"));
/**  @module did-jwt/JWT */
function isDIDOrMNID(mnidOrDid) {
    return mnidOrDid.match(/^did:/);
}
function normalizeDID(mnidOrDid) {
    if (mnidOrDid.match(/^did:/))
        return mnidOrDid;
    throw new Error(`Not a valid DID '${mnidOrDid}'`);
}
exports.normalizeDID = normalizeDID;
/**
 *  Decodes a JWT and returns an object representing the payload
 *
 *  @example
 *  decode('eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzI1NksifQ.eyJpYXQiOjE1...')
 *
 *  @param    {String}            jwt                a JSON Web Token to verify
 *  @return   {Object}                               a JS object representing the decoded JWT
 */
function decodeJwt(jwt) {
    if (!jwt)
        throw new Error("no JWT passed into decode");
    const parts = jwt.match(/^([a-zA-Z0-9_-]+)\.([a-zA-Z0-9_-]+)\.([a-zA-Z0-9_-]+)$/);
    if (parts) {
        return {
            header: JSON.parse(base64url_1.default.decode(parts[1])),
            payload: JSON.parse(base64url_1.default.decode(parts[2])),
            signature: parts[3],
            data: `${parts[1]}.${parts[2]}`,
        };
    }
    throw new Error("Incorrect format JWT");
}
exports.decodeJwt = decodeJwt;
/**
 *  Creates a signed JWT given an address which becomes the issuer, a signer, and a payload for which the signature is over.
 *
 *  @example
 *  const signer = SimpleSigner(process.env.PRIVATE_KEY)
 *  create({address: '5A8bRWU3F7j3REx3vkJ...', signer}, {key1: 'value', key2: ..., ... }).then(jwt => {
 *      ...
 *  })
 *
 *  @param    {Object}            payload            payload object
 *  @param    {Object}            [options]           an unsigned credential object
 *  @param    {String}            options.issuer      The DID of the issuer (signer) of JWT
 *  @param    {String}            options.alg         [DEPRECATED] The JWT signing algorithm to use. Supports: [ES256K, ES256K-R, Ed25519], Defaults to: ES256K.
 *                                                    Please use `header.alg` to specify the algorithm
 *  @param    {SimpleSigner}      options.signer      a signer, reference our SimpleSigner.js
 *  @param    {Object}            header             optional object to specify or customize the JWT header
 *  @return   {Promise<Object, Error>}               a promise which resolves with a signed JSON Web Token or rejects with an error
 */
async function createJwt(payload, { issuer, signer, alg, expiresIn }, header = {}) {
    if (!signer)
        throw new Error("No Signer functionality has been configured");
    if (!issuer)
        throw new Error("No issuing DID has been configured");
    const head = header;
    if (!header.typ)
        head.typ = "JWT";
    let algo = types_1.defaultAlg;
    if (header.alg) {
        algo = header.alg;
    }
    else if (alg) {
        algo = alg;
    }
    head.alg = algo;
    const timestamps = {
        iat: Math.floor(Date.now() / 1000),
        exp: undefined,
    };
    if (expiresIn) {
        if (typeof expiresIn === "number") {
            timestamps.exp = (payload.nbf || timestamps.iat) + Math.floor(expiresIn);
        }
        else {
            throw new Error("JWT expiresIn is not a number");
        }
    }
    const signingInput = [
        types_1.encodeSection(head),
        types_1.encodeSection({ ...timestamps, ...payload, iss: issuer }),
    ].join(".");
    const jwtSigner = SignerAlgorithm_1.default(algo);
    const signature = await jwtSigner.sign(signingInput, signer);
    return [signingInput, signature].join(".");
}
exports.createJwt = createJwt;
/**
 *  Verifies given JWT. If the JWT is valid, the promise returns an object including the JWT, the payload of the JWT,
 *  and the did doc of the issuer of the JWT.
 *
 *  @example
 *  verifyJWT('did:uport:eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzI1NksifQ.eyJyZXF1Z....', {audience: '5A8bRWU3F7j3REx3vkJ...', callbackUrl: 'https://...'}).then(obj => {
 *      const did = obj.did // DID of signer
 *      const payload = obj.payload
 *      const doc = obj.doc // DID Document of signer
 *      const jwt = obj.jwt
 *      const signerKeyId = obj.signerKeyId // ID of key in DID document that signed JWT
 *      ...
 *  })
 *
 *  @param    {String}            jwt                a JSON Web Token to verify
 *  @param    {Object}            [options]           an unsigned credential object
 *  @param    {Boolean}           options.auth        Require signer to be listed in the authentication section of the DID document (for Authentication purposes)
 *  @param    {String}            options.audience    DID of the recipient of the JWT
 *  @param    {String}            options.callbackUrl callback url in JWT
 *  @return   {Promise<Object, Error>}               a promise which resolves with a response object or rejects with an error
 */
async function ebsiVerifyJwt(jwt, options = {
    resolver: undefined,
    auth: undefined,
    audience: undefined,
    callbackUrl: undefined,
}) {
    if (!options.resolver)
        throw new Error("No DID resolver has been configured");
    const aud = options.audience ? normalizeDID(options.audience) : undefined;
    const { payload, header, signature, data } = decodeJwt(jwt);
    if (!payload.iss)
        throw new Error("No issuer specified");
    const { doc, authenticators, issuer, } = await resolveAuthenticator_1.default(options.resolver, header.alg, payload.iss === "https://self-issued.me"
        ? header.kid.replace("#key-1", "")
        : payload.iss, options.auth);
    const signer = VerifierAlgorithm_1.default(header.alg).verify(data, signature, authenticators);
    const now = Math.floor(Date.now() / 1000);
    const nowSkewed = now + types_1.NBF_SKEW;
    if (payload.nbf) {
        if (payload.nbf > nowSkewed) {
            throw new Error(`JWT not valid before nbf: ${payload.nbf}`);
        }
    }
    else if (payload.iat && payload.iat > nowSkewed) {
        throw new Error(`JWT not valid yet (issued in the future) iat: ${payload.iat}`);
    }
    if (payload.exp && payload.exp <= now - types_1.NBF_SKEW) {
        throw new Error(`JWT has expired: exp: ${payload.exp} < now: ${now}`);
    }
    if (payload.aud) {
        if (isDIDOrMNID(payload.aud)) {
            if (!aud) {
                throw new Error("JWT audience is required but your app address has not been configured");
            }
            if (aud !== normalizeDID(payload.aud)) {
                throw new Error(`JWT audience does not match your DID: aud: ${payload.aud} !== yours: ${aud}`);
            }
        }
        else {
            if (!options.callbackUrl) {
                throw new Error("JWT audience matching your callback url is required but one wasn't passed in");
            }
            if (payload.aud !== options.callbackUrl) {
                throw new Error(`JWT audience does not match the callback url: aud: ${payload.aud} !== url: ${options.callbackUrl}`);
            }
        }
    }
    return { payload, doc, issuer, signer, jwt };
}
exports.ebsiVerifyJwt = ebsiVerifyJwt;
/**
 *  Verifies given JWS. If the JWS is valid, returns the public key that was
 *  used to sign the JWS, or throws an `Error` if none of the `pubkeys` match.
 *
 *  @example
 *  const pubkey = verifyJWT('eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzI1NksifQ.eyJyZXF1Z....', { publicKeyHex: '0x12341...' })
 *
 *  @param    {String}                          jws         A JWS string to verify
 *  @param    {Array<PublicKey> | PublicKey}    pubkeys     The public keys used to verify the JWS
 *  @return   {PublicKey}                       The public key used to sign the JWS
 */
function verifyJWS(jws, publickeys) {
    let pubkeys;
    if (!Array.isArray(publickeys)) {
        pubkeys = [publickeys];
    }
    else {
        pubkeys = publickeys;
    }
    const { header, data, signature } = decodeJwt(jws);
    const signer = VerifierAlgorithm_1.default(header.alg).verify(data, signature, pubkeys);
    return signer;
}
exports.verifyJWS = verifyJWS;
/**
 *  Verifies given JWT. If the JWT is valid, the promise returns an object including the JWT, the payload of the JWT,
 *  and the did doc of the issuer of the JWT.
 *
 *  @example
 *  verifyJWT('did:uport:eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzI1NksifQ.eyJyZXF1Z....', {audience: '5A8bRWU3F7j3REx3vkJ...', callbackUrl: 'https://...'}).then(obj => {
 *      const did = obj.did // DID of signer
 *      const payload = obj.payload
 *      const doc = obj.doc // DID Document of signer
 *      const jwt = obj.jwt
 *      const signerKeyId = obj.signerKeyId // ID of key in DID document that signed JWT
 *      ...
 *  })
 *
 *  @param    {String}            jwt                a JSON Web Token to verify
 *  @param    {Object}            [options]           an unsigned credential object
 *  @param    {Boolean}           options.auth        Require signer to be listed in the authentication section of the DID document (for Authentication purposes)
 *  @param    {String}            options.audience    DID of the recipient of the JWT
 *  @param    {String}            options.callbackUrl callback url in JWT
 *  @return   {Promise<Object, Error>}               a promise which resolves with a response object or rejects with an error
 */
async function verifyJwt(jwt, options = {
    resolver: undefined,
    auth: undefined,
    audience: undefined,
    callbackUrl: undefined,
}) {
    if (!options.resolver)
        throw new Error("No DID resolver has been configured");
    const { payload, header } = decodeJwt(jwt);
    const { doc, authenticators, issuer, } = await resolveAuthenticator_1.default(options.resolver, header.alg, payload.iss === undefined ? "" : payload.iss, options.auth);
    const signer = verifyJWS(jwt, authenticators);
    const now = Math.floor(Date.now() / 1000);
    if (signer) {
        const nowSkewed = now + types_1.NBF_SKEW;
        if (payload.nbf) {
            if (payload.nbf > nowSkewed) {
                throw new Error(`JWT not valid before nbf: ${payload.nbf}`);
            }
        }
        else if (payload.iat && payload.iat > nowSkewed) {
            throw new Error(`JWT not valid yet (issued in the future) iat: ${payload.iat}`);
        }
        if (payload.exp && payload.exp <= now - types_1.NBF_SKEW) {
            throw new Error(`JWT has expired: exp: ${payload.exp} < now: ${now}`);
        }
        if (payload.aud) {
            if (!options.audience && !options.callbackUrl) {
                throw new Error("JWT audience is required but your app address has not been configured");
            }
            const audArray = Array.isArray(payload.aud) ? payload.aud : [payload.aud];
            const matchedAudience = audArray.find((item) => options.audience === item || options.callbackUrl === item);
            if (typeof matchedAudience === "undefined") {
                throw new Error(`JWT audience does not match your DID or callback url`);
            }
        }
        return { payload, doc, issuer, signer, jwt };
    }
    throw new Error("No signer found");
}
exports.verifyJwt = verifyJwt;
//# sourceMappingURL=jwt.js.map