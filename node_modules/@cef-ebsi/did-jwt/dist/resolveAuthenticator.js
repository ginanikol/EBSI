"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const axios_1 = __importDefault(require("axios"));
const types_1 = require("./types");
/**
 * Resolves relevant public keys or other authenticating material used to verify signature from the DID document of provided DID
 *
 *  @example
 *  resolveAuthenticator(resolver, 'ES256K', 'did:uport:2nQtiQG6Cgm1GYTBaaKAgr76uY7iSexUkqX').then(obj => {
 *      const payload = obj.payload
 *      const profile = obj.profile
 *      const jwt = obj.jwt
 *      ...
 *  })
 *
 *  @param    {String}            alg                a JWT algorithm
 *  @param    {String}            did                a Decentralized IDentifier (DID) to lookup
 *  @param    {Boolean}           auth               Restrict public keys to ones specifically listed in the 'authentication' section of DID document
 *  @return   {Promise<Object, Error>}               a promise which resolves with a response object containing an array of authenticators or if non exist rejects with an error
 */
async function resolveAuthenticator(resolver, alg, issuer, auth) {
    const types = types_1.SUPPORTED_PUBLIC_KEY_TYPES[alg];
    if (!types || types.length === 0) {
        throw new Error(`No supported signature types for algorithm ${alg}`);
    }
    let doc;
    if (typeof resolver === "string") {
        const response = await axios_1.default.get(`${resolver}/${issuer}`);
        doc = response.data;
    }
    else {
        doc = await resolver.resolve(issuer);
    }
    if (!doc)
        throw new Error(`Unable to resolve DID document for ${issuer}`);
    // is there some way to have authenticationKeys be a single type?
    const authenticationKeys = auth
        ? (doc.authentication || []).map(({ publicKey }) => publicKey)
        : true;
    const authenticators = (doc.publicKey || []).filter(({ type, id }) => types.find((supported) => {
        return (supported === type &&
            (!auth ||
                (Array.isArray(authenticationKeys) &&
                    authenticationKeys.indexOf(id) >= 0)));
    }));
    if (auth && (!authenticators || authenticators.length === 0)) {
        throw new Error(`DID document for ${issuer} does not have public keys suitable for authenticationg user`);
    }
    if (!authenticators || authenticators.length === 0) {
        throw new Error(`DID document for ${issuer} does not have public keys for ${alg}`);
    }
    return { authenticators, issuer, doc };
}
exports.default = resolveAuthenticator;
//# sourceMappingURL=resolveAuthenticator.js.map