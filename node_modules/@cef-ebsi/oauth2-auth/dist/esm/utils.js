import crypto from "node:crypto";
import { hexToBytes, utf8ToBytes, bytesToHex } from "@noble/hashes/utils";
import { encrypt as eciesEncrypt, decrypt as eciesDecrypt } from "eciesjs";
import { SCOPE, defaultExpiration } from "./constants.js";
import { InvalidTokenError, InvalidScopeError } from "./errors/index.js";
export function decode(token) {
    const jwtParts = token.split(".");
    let headers;
    let payload;
    try {
        headers = JSON.parse(Buffer.from(jwtParts[0], "base64").toString());
        payload = JSON.parse(Buffer.from(jwtParts[1], "base64").toString());
    }
    catch (error) {
        throw new InvalidTokenError(`The token can not be parsed: ${error.message || ""}`);
    }
    return { headers, payload };
}
export function checkHeaders(headers) {
    const algorithm = "ES256K";
    if (headers.alg !== algorithm) {
        throw new InvalidTokenError(`The token algorithm must be '${algorithm}'. Received '${headers.alg || ""}'`);
    }
    if (headers.typ !== "JWT") {
        throw new InvalidTokenError("assertion has not typ=JWT in the header");
    }
    return true;
}
function checkPayloadAttributes(payload) {
    if (!payload.aud ||
        !payload.iss ||
        !payload.exp ||
        !payload.sub ||
        !payload["nonce"] ||
        !payload.iat)
        return false;
    return true;
}
export function checkAssertionTokenPayload(payload) {
    if (!checkPayloadAttributes(payload) || !payload.jti) {
        throw new InvalidTokenError("Assertion token requires aud, iss, exp, sub, jti, nonce and iat in the payload");
    }
    const { iat, exp } = payload;
    if (!exp || !iat || exp - iat > defaultExpiration.requestToken) {
        throw new InvalidTokenError(`The expiration time can not exceed ${defaultExpiration.requestToken} seconds`);
    }
    return true;
}
export function checkAccessTokenPayload(payload, opts = {}) {
    const { scope, audience } = opts;
    let { expiration } = opts;
    if (!expiration) {
        expiration = defaultExpiration;
    }
    if (!checkPayloadAttributes(payload) || !payload["atHash"]) {
        throw new InvalidTokenError("Access token requires aud, iss, exp, sub, atHash, nonce and iat in the payload");
    }
    const { iat, exp } = payload;
    const expirationTime = expiration.accessToken
        ? expiration.accessToken
        : defaultExpiration.accessToken;
    const now = Math.floor(new Date().getTime() / 1000);
    if (!exp || !iat || exp - iat > expirationTime) {
        throw new InvalidTokenError(`The expiration time can not exceed ${expirationTime} seconds`);
    }
    if (iat > now)
        throw new InvalidTokenError(`iat cannot be later than present`);
    if (now > exp)
        throw new InvalidTokenError(`Access token is expired`);
    if (audience && payload.aud !== audience) {
        throw new InvalidTokenError(`The aud in the token must be ${audience}`);
    }
    if (scope && scope !== SCOPE) {
        throw new InvalidScopeError(`Invalid scope '${scope}'`);
    }
    return true;
}
export function checkHeadersPayload(token, options) {
    const { headers, payload } = decode(token);
    checkHeaders(headers);
    if (!options) {
        checkAssertionTokenPayload(payload);
        return { headers, payload };
    }
    const opts = { ...options };
    if (!opts.scope) {
        opts.scope = SCOPE;
    }
    checkAccessTokenPayload(payload, opts);
    return { headers, payload, scope: opts.scope };
}
export function encrypt(payload, publicKeyHex) {
    const encrypted = eciesEncrypt(publicKeyHex, utf8ToBytes(JSON.stringify(payload)));
    return bytesToHex(encrypted);
}
export function decrypt(privateKey, encrypted) {
    const decrypted = eciesDecrypt(privateKey, hexToBytes(encrypted));
    return new TextDecoder().decode(decrypted);
}
export function computeHash(payload) {
    const cryptoHash = crypto.createHash("sha256");
    cryptoHash.update(payload);
    return cryptoHash.digest();
}
//# sourceMappingURL=utils.js.map