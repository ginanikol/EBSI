"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyJwtTar = void 0;
const did_jwt_1 = require("did-jwt");
const siop_auth_1 = require("@cef-ebsi/siop-auth");
const key_encoder_1 = require("@cef-ebsi/key-encoder");
const basics_1 = require("multiformats/basics");
const jose_1 = require("jose");
const { base64 } = basics_1.bases;
const keyEncoder = new key_encoder_1.KeyEncoder("secp256k1");
function verifyJwtTar(jwt, opts) {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function* () {
        const { header, payload } = (0, did_jwt_1.decodeJWT)(jwt);
        const { kid } = header;
        if (!kid || !kid.startsWith(opts.trustedAppsRegistry)) {
            throw new Error(`JWT with invalid kid. It should be hosted at ${opts.trustedAppsRegistry}`);
        }
        if (typeof payload.iss !== "string") {
            throw new Error("JWT with invalid iss. It must be a string");
        }
        if (opts.op && opts.op !== (0, siop_auth_1.getGenericName)(payload.iss)) {
            throw new Error(`Invalid OpenID Provider. Received ${payload.iss}. Expected ${opts.op}`);
        }
        const tApp = yield (0, siop_auth_1.getApp)(kid, {
            timeout: opts.timeout,
        });
        if (!tApp.name || tApp.name !== payload.iss) {
            throw new Error(`kid resolves the app '${(_a = tApp.name) !== null && _a !== void 0 ? _a : ""}' but the iss field in the jwt refers to the app '${(_b = payload.iss) !== null && _b !== void 0 ? _b : ""}'`);
        }
        const validations = yield Promise.all(tApp.publicKeys.map((publicKeyPemBase64) => __awaiter(this, void 0, void 0, function* () {
            try {
                const publicKeyPem = basics_1.bytes.toString(base64.baseDecode(publicKeyPemBase64));
                const publicKeyHex = keyEncoder.encodePublic(publicKeyPem, "pem", "raw");
                const publicKeyJwk = siop_auth_1.encode.publicKey.fromHexToJWK(publicKeyHex);
                const publicKey = yield (0, jose_1.importJWK)(publicKeyJwk, header.alg);
                const verifyResult = yield (0, jose_1.jwtVerify)(jwt, publicKey);
                return {
                    valid: true,
                    result: Object.assign(Object.assign({}, verifyResult), { publicKeyHex,
                        publicKey }),
                };
            }
            catch (error) {
                return {
                    valid: false,
                    error,
                };
            }
        })));
        const [valid] = validations.filter((v) => v.valid);
        if (!valid) {
            throw new Error(`JWT could not be validated with the public keys of '${tApp.name}'. Errors: ${JSON.stringify(validations.map((v) => v.error.message))}`);
        }
        const aud = payload.aud;
        const sub = payload.sub;
        yield (0, siop_auth_1.getApp)(`${opts.trustedAppsRegistry}/${aud}`, {
            timeout: opts.timeout,
        });
        if (sub !== tApp.name) {
            yield (0, siop_auth_1.getApp)(`${opts.trustedAppsRegistry}/${sub}`, {
                timeout: opts.timeout,
            });
        }
        yield (0, siop_auth_1.checkAuthorization)(aud, sub, opts);
        return valid.result;
    });
}
exports.verifyJwtTar = verifyJwtTar;
//# sourceMappingURL=verifier.js.map