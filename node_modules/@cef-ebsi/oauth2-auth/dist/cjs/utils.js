"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.computeHash = exports.decrypt = exports.encrypt = exports.checkHeadersPayload = exports.checkAccessTokenPayload = exports.checkAssertionTokenPayload = exports.checkHeaders = exports.decode = void 0;
const node_crypto_1 = __importDefault(require("node:crypto"));
const utils_1 = require("@noble/hashes/utils");
const eciesjs_1 = require("eciesjs");
const constants_js_1 = require("./constants.js");
const index_js_1 = require("./errors/index.js");
function decode(token) {
    const jwtParts = token.split(".");
    let headers;
    let payload;
    try {
        headers = JSON.parse(Buffer.from(jwtParts[0], "base64").toString());
        payload = JSON.parse(Buffer.from(jwtParts[1], "base64").toString());
    }
    catch (error) {
        throw new index_js_1.InvalidTokenError(`The token can not be parsed: ${error.message || ""}`);
    }
    return { headers, payload };
}
exports.decode = decode;
function checkHeaders(headers) {
    const algorithm = "ES256K";
    if (headers.alg !== algorithm) {
        throw new index_js_1.InvalidTokenError(`The token algorithm must be '${algorithm}'. Received '${headers.alg || ""}'`);
    }
    if (headers.typ !== "JWT") {
        throw new index_js_1.InvalidTokenError("assertion has not typ=JWT in the header");
    }
    return true;
}
exports.checkHeaders = checkHeaders;
function checkPayloadAttributes(payload) {
    if (!payload.aud ||
        !payload.iss ||
        !payload.exp ||
        !payload.sub ||
        !payload["nonce"] ||
        !payload.iat)
        return false;
    return true;
}
function checkAssertionTokenPayload(payload) {
    if (!checkPayloadAttributes(payload) || !payload.jti) {
        throw new index_js_1.InvalidTokenError("Assertion token requires aud, iss, exp, sub, jti, nonce and iat in the payload");
    }
    const { iat, exp } = payload;
    if (!exp || !iat || exp - iat > constants_js_1.defaultExpiration.requestToken) {
        throw new index_js_1.InvalidTokenError(`The expiration time can not exceed ${constants_js_1.defaultExpiration.requestToken} seconds`);
    }
    return true;
}
exports.checkAssertionTokenPayload = checkAssertionTokenPayload;
function checkAccessTokenPayload(payload, opts = {}) {
    const { scope, audience } = opts;
    let { expiration } = opts;
    if (!expiration) {
        expiration = constants_js_1.defaultExpiration;
    }
    if (!checkPayloadAttributes(payload) || !payload["atHash"]) {
        throw new index_js_1.InvalidTokenError("Access token requires aud, iss, exp, sub, atHash, nonce and iat in the payload");
    }
    const { iat, exp } = payload;
    const expirationTime = expiration.accessToken
        ? expiration.accessToken
        : constants_js_1.defaultExpiration.accessToken;
    const now = Math.floor(new Date().getTime() / 1000);
    if (!exp || !iat || exp - iat > expirationTime) {
        throw new index_js_1.InvalidTokenError(`The expiration time can not exceed ${expirationTime} seconds`);
    }
    if (iat > now)
        throw new index_js_1.InvalidTokenError(`iat cannot be later than present`);
    if (now > exp)
        throw new index_js_1.InvalidTokenError(`Access token is expired`);
    if (audience && payload.aud !== audience) {
        throw new index_js_1.InvalidTokenError(`The aud in the token must be ${audience}`);
    }
    if (scope && scope !== constants_js_1.SCOPE) {
        throw new index_js_1.InvalidScopeError(`Invalid scope '${scope}'`);
    }
    return true;
}
exports.checkAccessTokenPayload = checkAccessTokenPayload;
function checkHeadersPayload(token, options) {
    const { headers, payload } = decode(token);
    checkHeaders(headers);
    if (!options) {
        checkAssertionTokenPayload(payload);
        return { headers, payload };
    }
    const opts = Object.assign({}, options);
    if (!opts.scope) {
        opts.scope = constants_js_1.SCOPE;
    }
    checkAccessTokenPayload(payload, opts);
    return { headers, payload, scope: opts.scope };
}
exports.checkHeadersPayload = checkHeadersPayload;
function encrypt(payload, publicKeyHex) {
    const encrypted = (0, eciesjs_1.encrypt)(publicKeyHex, (0, utils_1.utf8ToBytes)(JSON.stringify(payload)));
    return (0, utils_1.bytesToHex)(encrypted);
}
exports.encrypt = encrypt;
function decrypt(privateKey, encrypted) {
    const decrypted = (0, eciesjs_1.decrypt)(privateKey, (0, utils_1.hexToBytes)(encrypted));
    return new TextDecoder().decode(decrypted);
}
exports.decrypt = decrypt;
function computeHash(payload) {
    const cryptoHash = node_crypto_1.default.createHash("sha256");
    cryptoHash.update(payload);
    return cryptoHash.digest();
}
exports.computeHash = computeHash;
//# sourceMappingURL=utils.js.map