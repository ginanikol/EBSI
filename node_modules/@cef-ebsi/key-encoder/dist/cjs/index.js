"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeyEncoder = void 0;
const elliptic_1 = __importDefault(require("elliptic"));
const asn1_js_1 = __importDefault(require("asn1.js"));
const EC = elliptic_1.default.ec;
const curves = {
    secp256k1: {
        curveParameters: [1, 3, 132, 0, 10],
        privatePEMOptions: { label: "EC PRIVATE KEY" },
        publicPEMOptions: { label: "PUBLIC KEY" },
        curve: new EC("secp256k1"),
    },
};
const ECPrivateKeyASN = asn1_js_1.default.define("ECPrivateKey", function () {
    this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").explicit(0).objid().optional(), this.key("publicKey").explicit(1).bitstr().optional());
});
const ECPrivateKey8ASN = asn1_js_1.default.define("ECPrivateKey", function () {
    this.seq().obj(this.key("version").int(), this.key("privateKeyAlgorithm")
        .seq()
        .obj(this.key("ecPublicKey").objid(), this.key("curve").objid()), this.key("privateKey").octstr().contains(ECPrivateKeyASN), this.key("attributes").explicit(0).bitstr().optional());
});
const SubjectPublicKeyInfoASN = asn1_js_1.default.define("SubjectPublicKeyInfo", function () {
    this.seq().obj(this.key("algorithm")
        .seq()
        .obj(this.key("id").objid(), this.key("curve").objid()), this.key("pub").bitstr());
});
class KeyEncoder {
    constructor(options) {
        if (typeof options === "string") {
            if (options !== "secp256k1") {
                throw new Error(`Unknown curve ${options}`);
            }
            options = curves[options];
        }
        this.options = options;
        this.algorithmID = [1, 2, 840, 10045, 2, 1];
    }
    PKCS1toPKCS8(privateKey) {
        return {
            version: 0,
            privateKey,
            privateKeyAlgorithm: {
                ecPublicKey: this.algorithmID,
                curve: privateKey.parameters,
            },
        };
    }
    privateKeyObject(rawPrivateKey, rawPublicKey) {
        const privateKeyObject = {
            version: 1,
            privateKey: Buffer.from(rawPrivateKey, "hex"),
            parameters: this.options.curveParameters,
        };
        if (rawPublicKey) {
            privateKeyObject.publicKey = {
                unused: 0,
                data: Buffer.from(rawPublicKey, "hex"),
            };
        }
        return privateKeyObject;
    }
    publicKeyObject(rawPublicKey) {
        return {
            algorithm: {
                id: this.algorithmID,
                curve: this.options.curveParameters,
            },
            pub: {
                unused: 0,
                data: Buffer.from(rawPublicKey, "hex"),
            },
        };
    }
    encodePrivate(privateKey, originalFormat, destinationFormat, destinationFormatType = "pkcs1") {
        let privateKeyObject;
        if (originalFormat === "raw") {
            if (typeof privateKey !== "string") {
                throw new Error("private key must be a string");
            }
            let keyPair = this.options.curve.keyFromPrivate(privateKey, "hex");
            let rawPublicKey = keyPair.getPublic("hex");
            privateKeyObject = this.privateKeyObject(privateKey, rawPublicKey);
        }
        else if (originalFormat === "der") {
            if (typeof privateKey !== "string") {
            }
            else if (typeof privateKey === "string") {
                privateKey = Buffer.from(privateKey, "hex");
            }
            else {
                throw new Error("private key must be a buffer or a string");
            }
            privateKeyObject = ECPrivateKeyASN.decode(privateKey, "der");
        }
        else if (originalFormat === "pem") {
            if (typeof privateKey !== "string") {
                throw new Error("private key must be a string");
            }
            privateKeyObject = ECPrivateKeyASN.decode(privateKey, "pem", this.options.privatePEMOptions);
        }
        else {
            throw new Error("invalid private key format");
        }
        if (destinationFormat === "raw") {
            return privateKeyObject.privateKey.toString("hex");
        }
        else if (destinationFormat === "der") {
            return ECPrivateKeyASN.encode(privateKeyObject, "der").toString("hex");
        }
        else if (destinationFormat === "pem") {
            return destinationFormatType === "pkcs1"
                ? ECPrivateKeyASN.encode(privateKeyObject, "pem", this.options.privatePEMOptions)
                : ECPrivateKey8ASN.encode(this.PKCS1toPKCS8(privateKeyObject), "pem", Object.assign(Object.assign({}, this.options.privatePEMOptions), { label: "PRIVATE KEY" }));
        }
        else {
            throw new Error("invalid destination format for private key");
        }
    }
    encodePublic(publicKey, originalFormat, destinationFormat) {
        let publicKeyObject;
        if (originalFormat === "raw") {
            if (typeof publicKey !== "string") {
                throw new Error("public key must be a string");
            }
            publicKeyObject = this.publicKeyObject(publicKey);
        }
        else if (originalFormat === "der") {
            if (typeof publicKey !== "string") {
            }
            else if (typeof publicKey === "string") {
                publicKey = Buffer.from(publicKey, "hex");
            }
            else {
                throw new Error("public key must be a buffer or a string");
            }
            publicKeyObject = SubjectPublicKeyInfoASN.decode(publicKey, "der");
        }
        else if (originalFormat === "pem") {
            if (typeof publicKey !== "string") {
                throw new Error("public key must be a string");
            }
            publicKeyObject = SubjectPublicKeyInfoASN.decode(publicKey, "pem", this.options.publicPEMOptions);
        }
        else {
            throw new Error("invalid public key format");
        }
        if (destinationFormat === "raw") {
            return publicKeyObject.pub.data.toString("hex");
        }
        else if (destinationFormat === "der") {
            return SubjectPublicKeyInfoASN.encode(publicKeyObject, "der").toString("hex");
        }
        else if (destinationFormat === "pem") {
            return SubjectPublicKeyInfoASN.encode(publicKeyObject, "pem", this.options.publicPEMOptions);
        }
        else {
            throw new Error("invalid destination format for public key");
        }
    }
}
exports.KeyEncoder = KeyEncoder;
KeyEncoder.ECPrivateKeyASN = ECPrivateKeyASN;
KeyEncoder.ECPrivateKey8ASN = ECPrivateKey8ASN;
KeyEncoder.SubjectPublicKeyInfoASN = SubjectPublicKeyInfoASN;
//# sourceMappingURL=index.js.map