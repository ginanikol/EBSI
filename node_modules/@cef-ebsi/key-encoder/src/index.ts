import elliptic from "elliptic";
import asn1 from "asn1.js";

const EC = elliptic.ec;

interface PrivateKeyPKCS1 {
  version: number;
  privateKey: Buffer;
  parameters: readonly number[];
  publicKey?: {
    unused: number;
    data: Buffer;
  };
}

interface PrivateKeyPKCS8 {
  version: number;
  privateKey: PrivateKeyPKCS1;
  privateKeyAlgorithm: {
    ecPublicKey: number[];
    curve: readonly number[];
  };
}

interface CurveOptions {
  curveParameters: readonly number[];
  privatePEMOptions: { label: string };
  publicPEMOptions: { label: string };
  curve: elliptic.ec;
}

const curves = {
  secp256k1: {
    curveParameters: [1, 3, 132, 0, 10],
    privatePEMOptions: { label: "EC PRIVATE KEY" },
    publicPEMOptions: { label: "PUBLIC KEY" },
    curve: new EC("secp256k1"),
  },
} as const satisfies { [index: string]: CurveOptions };

type KeyFormat = "raw" | "pem" | "der";

/* eslint-disable */
const ECPrivateKeyASN = asn1.define("ECPrivateKey", function (this: any) {
  this.seq().obj(
    this.key("version").int(),
    this.key("privateKey").octstr(),
    this.key("parameters").explicit(0).objid().optional(),
    this.key("publicKey").explicit(1).bitstr().optional(),
  );
});

const ECPrivateKey8ASN = asn1.define("ECPrivateKey", function (this: any) {
  this.seq().obj(
    this.key("version").int(),
    this.key("privateKeyAlgorithm")
      .seq()
      .obj(this.key("ecPublicKey").objid(), this.key("curve").objid()),
    this.key("privateKey").octstr().contains(ECPrivateKeyASN),
    this.key("attributes").explicit(0).bitstr().optional(),
  );
});

const SubjectPublicKeyInfoASN = asn1.define(
  "SubjectPublicKeyInfo",
  function (this: any) {
    this.seq().obj(
      this.key("algorithm")
        .seq()
        .obj(this.key("id").objid(), this.key("curve").objid()),
      this.key("pub").bitstr(),
    );
  },
);

export class KeyEncoder {
  static ECPrivateKeyASN = ECPrivateKeyASN;
  static ECPrivateKey8ASN = ECPrivateKey8ASN;
  static SubjectPublicKeyInfoASN = SubjectPublicKeyInfoASN;

  algorithmID: number[];
  options: CurveOptions;

  constructor(options: string | CurveOptions) {
    if (typeof options === "string") {
      if (options !== "secp256k1") {
        throw new Error(`Unknown curve ${options}`);
      }
      options = curves[options];
    }
    this.options = options;
    this.algorithmID = [1, 2, 840, 10045, 2, 1];
  }

  private PKCS1toPKCS8(privateKey: PrivateKeyPKCS1): PrivateKeyPKCS8 {
    return {
      version: 0,
      privateKey,
      privateKeyAlgorithm: {
        ecPublicKey: this.algorithmID,
        curve: privateKey.parameters,
      },
    };
  }

  privateKeyObject(rawPrivateKey: string, rawPublicKey: string) {
    const privateKeyObject: PrivateKeyPKCS1 = {
      version: 1,
      privateKey: Buffer.from(rawPrivateKey, "hex"),
      parameters: this.options.curveParameters,
    };

    if (rawPublicKey) {
      privateKeyObject.publicKey = {
        unused: 0,
        data: Buffer.from(rawPublicKey, "hex"),
      };
    }

    return privateKeyObject;
  }

  publicKeyObject(rawPublicKey: string) {
    return {
      algorithm: {
        id: this.algorithmID,
        curve: this.options.curveParameters,
      },
      pub: {
        unused: 0,
        data: Buffer.from(rawPublicKey, "hex"),
      },
    };
  }

  encodePrivate(
    privateKey: string | Buffer,
    originalFormat: KeyFormat,
    destinationFormat: KeyFormat,
    destinationFormatType: "pkcs8" | "pkcs1" = "pkcs1",
  ): string {
    let privateKeyObject: PrivateKeyPKCS1;

    /* Parse the incoming private key and convert it to a private key object */
    if (originalFormat === "raw") {
      if (typeof privateKey !== "string") {
        throw new Error("private key must be a string");
      }
      let keyPair = this.options.curve.keyFromPrivate(privateKey, "hex");
      let rawPublicKey = keyPair.getPublic("hex");
      privateKeyObject = this.privateKeyObject(privateKey, rawPublicKey);
    } else if (originalFormat === "der") {
      if (typeof privateKey !== "string") {
        // do nothing
      } else if (typeof privateKey === "string") {
        privateKey = Buffer.from(privateKey, "hex");
      } else {
        throw new Error("private key must be a buffer or a string");
      }
      privateKeyObject = ECPrivateKeyASN.decode(privateKey, "der");
    } else if (originalFormat === "pem") {
      if (typeof privateKey !== "string") {
        throw new Error("private key must be a string");
      }
      privateKeyObject = ECPrivateKeyASN.decode(
        privateKey,
        "pem",
        this.options.privatePEMOptions,
      );
    } else {
      throw new Error("invalid private key format");
    }

    /* Export the private key object to the desired format */
    if (destinationFormat === "raw") {
      return privateKeyObject.privateKey.toString("hex");
    } else if (destinationFormat === "der") {
      return ECPrivateKeyASN.encode(privateKeyObject, "der").toString("hex");
    } else if (destinationFormat === "pem") {
      return destinationFormatType === "pkcs1"
        ? ECPrivateKeyASN.encode(
            privateKeyObject,
            "pem",
            this.options.privatePEMOptions,
          )
        : ECPrivateKey8ASN.encode(this.PKCS1toPKCS8(privateKeyObject), "pem", {
            ...this.options.privatePEMOptions,
            label: "PRIVATE KEY",
          });
    } else {
      throw new Error("invalid destination format for private key");
    }
  }

  encodePublic(
    publicKey: string | Buffer,
    originalFormat: KeyFormat,
    destinationFormat: KeyFormat,
  ): string {
    let publicKeyObject;

    /* Parse the incoming public key and convert it to a public key object */
    if (originalFormat === "raw") {
      if (typeof publicKey !== "string") {
        throw new Error("public key must be a string");
      }
      publicKeyObject = this.publicKeyObject(publicKey);
    } else if (originalFormat === "der") {
      if (typeof publicKey !== "string") {
        // do nothing
      } else if (typeof publicKey === "string") {
        publicKey = Buffer.from(publicKey, "hex");
      } else {
        throw new Error("public key must be a buffer or a string");
      }
      publicKeyObject = SubjectPublicKeyInfoASN.decode(publicKey, "der");
    } else if (originalFormat === "pem") {
      if (typeof publicKey !== "string") {
        throw new Error("public key must be a string");
      }
      publicKeyObject = SubjectPublicKeyInfoASN.decode(
        publicKey,
        "pem",
        this.options.publicPEMOptions,
      );
    } else {
      throw new Error("invalid public key format");
    }

    /* Export the private key object to the desired format */
    if (destinationFormat === "raw") {
      return publicKeyObject.pub.data.toString("hex");
    } else if (destinationFormat === "der") {
      return SubjectPublicKeyInfoASN.encode(publicKeyObject, "der").toString(
        "hex",
      );
    } else if (destinationFormat === "pem") {
      return SubjectPublicKeyInfoASN.encode(
        publicKeyObject,
        "pem",
        this.options.publicPEMOptions,
      );
    } else {
      throw new Error("invalid destination format for public key");
    }
  }
}
/* eslint-enable */
