"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateSignature = exports.validateJwtProps = exports.validateType = exports.validateContext = exports.validateCredentials = exports.validateCredentialJwt = exports.validateCredentialSubject = exports.validateHolder = exports.isLegacyNaturalPersonDid = exports.validateTimestamp = exports.validateEbsiVerifiablePresentation = exports.getAjvInstance = void 0;
const ebsi_did_resolver_1 = require("@cef-ebsi/ebsi-did-resolver");
const verifiable_credential_1 = require("@cef-ebsi/verifiable-credential");
const key_did_resolver_1 = require("@cef-ebsi/key-did-resolver");
const mem_1 = __importDefault(require("mem"));
const json_web_signature_1 = require("@transmute/json-web-signature");
const vc_js_1 = require("@transmute/vc.js");
const jose_1 = require("jose");
// eslint-disable-next-line import/no-relative-packages
const schema_json_1 = __importDefault(require("./schemas/ebsi-presentation/2022-11/schema.json"));
const constants_1 = require("./constants");
exports.getAjvInstance = (0, mem_1.default)((timeout, trustedHostnames) => {
    // Configure Ajv
    const ajv = (0, verifiable_credential_1.getAjvInstance)(timeout, trustedHostnames);
    // Pre-register EBSI Verifiable Presentation 2022-02 schema
    ajv.addSchema(schema_json_1.default, constants_1.EBSI_VERIFIABLE_PRESENTATION_SCHEMA_ID_HEX);
    ajv.addSchema(schema_json_1.default, constants_1.EBSI_VERIFIABLE_PRESENTATION_SCHEMA_ID_MULTIBASE_BASE58BTC);
    return ajv;
});
/**
 * EBSI_VP_001: All the EBSI Verifiable Presentations MUST be conform to the Verifiable Presentation model.
 *
 * Validates that the given value is an EbsiVerifiablePresentation object.
 *
 * @param value - any value
 * @param schemaKey - Ajv cache key (URL) to be used for the EBSI VP schema
 * @param trustedSchemasRegistry - Trusted Schemas Registry API URL
 */
function validateEbsiVerifiablePresentation(value, timeout, trustedHostnames) {
    const ajv = (0, exports.getAjvInstance)(timeout, trustedHostnames);
    const validate = ajv.getSchema(constants_1.EBSI_VERIFIABLE_PRESENTATION_SCHEMA_ID_HEX);
    if (!validate) {
        throw new verifiable_credential_1.JsonSchemaLoadingError("Unable to get EBSI VP schema");
    }
    const valid = validate(value);
    if (!valid && validate.errors) {
        throw new verifiable_credential_1.JsonSchemaValidationError("Invalid EBSI Verifiable Presentation", validate.errors);
    }
}
exports.validateEbsiVerifiablePresentation = validateEbsiVerifiablePresentation;
/**
 * Validates that the given value is a valid timestamp.
 *
 * @param value - value to validate
 */
function validateTimestamp(value) {
    if (typeof value === "number") {
        if (!(Number.isInteger(value) && value < 100000000000)) {
            throw new verifiable_credential_1.ValidationError(`"${value}" is not a unix timestamp in seconds`);
        }
    }
    else {
        throw new verifiable_credential_1.ValidationError("Invalid timestamp provided. Only numbers are supported.");
    }
}
exports.validateTimestamp = validateTimestamp;
/**
 * Helper function that checks if a DID is a legacy `did:ebsi` v2 (NP) DID.
 *
 * @param did - The DID to check.
 * @returns True if the DID is a legacy `did:ebsi` v2 DID, false otherwise.
 */
function isLegacyNaturalPersonDid(did) {
    try {
        const version = (0, ebsi_did_resolver_1.validate)(did);
        return version === ebsi_did_resolver_1.EBSI_DID_SPECS.NATURAL_PERSON.VERSION_ID;
    }
    catch {
        return false;
    }
}
exports.isLegacyNaturalPersonDid = isLegacyNaturalPersonDid;
/**
 * Validates the presentation holder.
 *
 * Rules:
 * - the holder DID MUST be a valid EBSI DID
 * - both DIDs (`payload.holder` and `holder`) MUST match
 * - the holder `kid` MUST be related to the holder DID (starts with the holder DID)
 * - (optional) the holder DID SHOULD resolve to a valid DID document
 * - (optional) `kid` SHOULD be a valid verification method in the DID document
 *
 * @param payload - an EbsiVerifiablePresentation
 * @param holder - the VP holder's DID
 * @param kid - the kid of the key used to sign the VP
 * @param proofPurpose - one of "authentication", "assertionMethod", "capabilityInvocation", "capabilityDelegation". Default: "authentication"
 * @param timeout - Axios timeout (default: 15 seconds)
 */
async function validateHolder(payload, holder, kid, resolver, proofPurpose = "authentication", timeout = constants_1.AXIOS_TIMEOUT, skipHolderDidResolutionValidation = false) {
    (0, verifiable_credential_1.validateDid)(holder);
    if (payload.holder !== holder) {
        throw new verifiable_credential_1.ValidationError(`payload.holder "${payload.holder}" and holder "${holder}" don't match`);
    }
    // Validate kid. EBSI_JWT_VP_003
    if (typeof kid !== "string") {
        throw new verifiable_credential_1.ValidationError("kid is required");
    }
    if (kid.indexOf("#") === -1) {
        throw new verifiable_credential_1.ValidationError(`kid doesn't contain "#"`);
    }
    if (kid.split("#")[0] !== holder) {
        throw new verifiable_credential_1.ValidationError("did and kid don't match");
    }
    // EBSI_VP_003
    // Verify that the holder is registered in the DID Registry
    if (skipHolderDidResolutionValidation) {
        // Do not try to resolve holder DID
        return;
    }
    const { didDocument, didResolutionMetadata } = await resolver.resolve(holder, { timeout });
    if (!didDocument) {
        if (didResolutionMetadata.error &&
            typeof didResolutionMetadata.message === "string") {
            throw new verifiable_credential_1.ValidationError(`Unable to resolve ${holder}. Error: ${didResolutionMetadata.error}. ${didResolutionMetadata.message}`);
        }
        throw new verifiable_credential_1.ValidationError(`Couldn't find the DID document associated with ${holder}`);
    }
    // EBSI_JWT_VP_004
    const verificationMethods = [...(didDocument[proofPurpose] ?? [])];
    if (!verificationMethods?.find((method) => {
        if (typeof method === "string") {
            return method === kid;
        }
        return method.id === kid;
    })) {
        throw new verifiable_credential_1.ValidationError(`Could not find a verification method related to "${kid}" for the proof purpose "${proofPurpose}"`);
    }
}
exports.validateHolder = validateHolder;
/**
 * Validates that the VC credentialSubject matches the VP holder.
 *
 * @param holder - the VP holder's DID
 * @param payload - an EbsiVerifiablePresentation
 */
function validateCredentialSubject(payload, holder) {
    if (typeof payload.sub !== "string") {
        throw new verifiable_credential_1.ValidationError("JWT payload missing a sub field");
    }
    if (payload.sub !== holder) {
        throw new verifiable_credential_1.ValidationError(`VC subject "${payload.sub}" and VP holder "${holder}" don't match`);
    }
}
exports.validateCredentialSubject = validateCredentialSubject;
/**
 * Validates VC JWT in the context of the VP.
 *
 * @param vcJwt - Verifiable Credential as JWT
 * @param holder - the VP holder's DID
 * @param options - ebsiEnv, nbf, and exp to be used to verify the VC
 */
async function validateCredentialJwt(vcJwt, holder, options) {
    // Run VC @cef-ebsi/verifiable-credential validation
    await (0, verifiable_credential_1.verifyCredentialJwt)(vcJwt, options);
    const payload = (0, jose_1.decodeJwt)(vcJwt);
    // Check JWT sub. It MUST match the VP holder DID. EBSI_VP_005
    validateCredentialSubject(payload, holder);
    // VP's nbf can't be older than VC's nbf
    if (options.nbf && payload.nbf && options.nbf < payload.nbf) {
        throw new verifiable_credential_1.ValidationError(`VP's nbf (${options.nbf}) can't be older than VC's nbf (${payload.nbf})`);
    }
    // VP's exp can't be more recent than VC's exp
    if (options.exp && payload.exp && options.exp > payload.exp) {
        throw new verifiable_credential_1.ValidationError(`VP's exp (${options.exp}) can't be more recent than VC's exp (${payload.exp})`);
    }
}
exports.validateCredentialJwt = validateCredentialJwt;
/**
 * Validates all the VP's credentials. EBSI_VP_004
 *
 * @param payload - an EbsiVerifiablePresentation
 * @param holder - the VP holder's DID
 * @param options - CreateVerifiablePresentationJwtOptions object
 */
async function validateCredentials(payload, holder, options) {
    await Promise.all(payload.verifiableCredential.map(async (vcJwt) => {
        if (typeof vcJwt === "string") {
            return validateCredentialJwt(vcJwt, holder, options);
        }
        throw new verifiable_credential_1.ValidationError("Unsupported verifiableCredential type");
    }));
}
exports.validateCredentials = validateCredentials;
/**
 * Validates that the '\@context' is conform to the W3C specs.
 *
 * @param context - a set of URIs to validate
 */
function validateContext(context) {
    if (!Array.isArray(context)) {
        throw new verifiable_credential_1.ValidationError('"@context" must be an array of strings');
    }
    if (context[0] !== "https://www.w3.org/2018/credentials/v1") {
        throw new verifiable_credential_1.ValidationError('The first URI in "@context" must be "https://www.w3.org/2018/credentials/v1"');
    }
}
exports.validateContext = validateContext;
/**
 * Validates that the 'type' is conform to the W3C specs.
 *
 * @param type - a set of types to validate
 */
function validateType(type) {
    if (!Array.isArray(type)) {
        throw new verifiable_credential_1.ValidationError('"type" must be an array of strings');
    }
    if (type[0] !== "VerifiablePresentation") {
        throw new verifiable_credential_1.ValidationError('The first type must be "VerifiablePresentation"');
    }
}
exports.validateType = validateType;
/**
 * Validates the VP JWT properties. Ensures that all the properties are available and match the VP.
 *
 * Rules:
 * - The JWT payload "vp" property must be conform to the EBSI VP schema
 * - EBSI_JWT_VP_001 The JWT claims MUST match with the VC properties
 *
 * @param jwt - the VP JWT
 * @param audience - represents the identity of the intended audience
 * @param options - extra verification options
 */
function validateJwtProps(jwt, audience, options) {
    // EBSI_JWT_VP_001: verify JWT props match payload
    let payload;
    let header;
    try {
        payload = (0, jose_1.decodeJwt)(jwt);
        header = (0, jose_1.decodeProtectedHeader)(jwt);
    }
    catch (e) {
        throw new verifiable_credential_1.ValidationError("Unable to decode JWT VC");
    }
    /**
     * Header
     *
     * alg REQUIRED. The signature algorithm used to sign the VP.
     * kid REQUIRED. It MUST point to a DID URI resolving to an issuer's key in the DID document.
     * typ REQUIRED. MUST be JWT.
     */
    if (!header) {
        throw new verifiable_credential_1.ValidationError("Invalid JWT header");
    }
    if (!header.alg || typeof header.alg !== "string") {
        throw new verifiable_credential_1.ValidationError(`"alg" JWT header is required`);
    }
    if (!["ES256", "ES256K", "EdDSA"].includes(header.alg)) {
        throw new verifiable_credential_1.ValidationError(`${header.alg} is not a supported alg`);
    }
    if (!header.kid || typeof header.kid !== "string") {
        throw new verifiable_credential_1.ValidationError(`"kid" JWT header is required`);
    }
    // In this test, we simply check if the kid is a valid EBSI DID.
    // Another test will try to resolve a DID document based on this,
    // so we don't need to check if it's registered here.
    try {
        (0, verifiable_credential_1.validateDid)(header.kid.split("#")[0]);
    }
    catch (e) {
        throw new verifiable_credential_1.ValidationError(e instanceof Error ? e.message : '"kid" is not a valid EBSI DID');
    }
    if (!header.typ || header.typ !== "JWT") {
        throw new verifiable_credential_1.ValidationError(`"typ" JWT header must be "JWT"`);
    }
    /**
     * Payload
     *
     * iss REQUIRED. MUST match the value of the property holder of the Verifiable Presentation.
     * sub REQUIRED. MUST match the value of the property credentialSubject.id of the Verifiable Credential(s).
     * aud REQUIRED. MUST represent the identity of the intended audience.
     * jti OPTIONAL. SHOULD be a unique identifier for the Verifiable Presentation.
     * iat REQUIRED. Time at which the Verifiable Presentation has been issued.
     * nbf REQUIRED. Time before which the Verifiable Presentation MUST NOT be accepted for processing.
     * exp REQUIRED. Expiration time after which the Verifiable Presentation MUST NOT be accepted for processing.
     * vp	REQUIRED. MUST be a valid Verifiable Presentation JSON object.
     */
    const { vp, iss, sub, aud, jti, iat, nbf, exp } = payload;
    validateEbsiVerifiablePresentation(vp, options?.timeout, options?.trustedHostnames);
    if (!iss || iss !== vp.holder) {
        throw new verifiable_credential_1.ValidationError(`JWT "iss" property MUST match the VP holder "${vp.holder}"`);
    }
    if (!sub || sub !== vp.holder) {
        throw new verifiable_credential_1.ValidationError(`JWT "sub" property MUST match the VP holder "${vp.holder}"`);
    }
    // EBSI_JWT_VP_002
    if (!aud || aud !== audience) {
        throw new verifiable_credential_1.ValidationError(`JWT "aud" property MUST match the expected audience "${audience}"`);
    }
    if (jti && jti !== vp.id) {
        throw new verifiable_credential_1.ValidationError(`JWT "jti" property MUST match the VP ID "${vp.id}"`);
    }
    if (!iat) {
        throw new verifiable_credential_1.ValidationError(`JWT "iat" property is required`);
    }
    if (iat) {
        validateTimestamp(iat);
    }
    if (!nbf) {
        throw new verifiable_credential_1.ValidationError(`JWT "nbf" property is required`);
    }
    if (nbf) {
        validateTimestamp(nbf);
    }
    if (!exp) {
        throw new verifiable_credential_1.ValidationError(`JWT "exp" property is required`);
    }
    if (exp) {
        validateTimestamp(exp);
    }
    if (nbf && exp && nbf > exp) {
        throw new verifiable_credential_1.ValidationError(`JWT "nbf" can't be more recent than "exp"`);
    }
    if (options?.validAt) {
        if (nbf && nbf > options.validAt) {
            throw new verifiable_credential_1.ValidationError("JWT is not valid yet");
        }
        if (exp && options.validAt > exp) {
            throw new verifiable_credential_1.ValidationError("JWT has expired");
        }
    }
    return { header: header, payload: payload };
}
exports.validateJwtProps = validateJwtProps;
async function validateSignature(jwt, resolver, options) {
    // TODO: memoize
    const documentLoader = async (iri) => {
        if (iri.startsWith(ebsi_did_resolver_1.EBSI_DID_METHOD_PREFIX) ||
            iri.startsWith(key_did_resolver_1.KEY_DID_METHOD_PREFIX)) {
            const { didDocument, didResolutionMetadata } = await resolver.resolve(iri, { timeout: options?.timeout });
            (0, verifiable_credential_1.handleDidResolutionErrors)(didDocument, didResolutionMetadata, iri);
            return {
                documentUrl: iri,
                document: didDocument,
            };
        }
        // Serve common contexts directly
        if (Object.prototype.hasOwnProperty.call(verifiable_credential_1.contexts, iri)) {
            return {
                documentUrl: iri,
                document: verifiable_credential_1.contexts[iri],
            };
        }
        // Fetch unknown documents
        const req = await (0, verifiable_credential_1.memGet)(iri, options?.timeout);
        return {
            documentUrl: iri,
            document: req.data,
        };
    };
    try {
        const verifyVpResult = await vc_js_1.verifiable.presentation.verify({
            presentation: jwt,
            format: ["vp-jwt"],
            documentLoader,
            suite: [new json_web_signature_1.JsonWebSignature()],
            challenge: "",
        });
        if (!verifyVpResult.verified) {
            throw new verifiable_credential_1.ValidationError("Invalid signature");
        }
    }
    catch (e) {
        const errorMessage = e instanceof Error ? e.message : "Reason unknown";
        // Fixes EBSIINT-6779
        if (errorMessage.includes("JWS.header contained unsupported alg")) {
            // Extract alg from error message
            const alg = errorMessage.split("JWS.header contained unsupported alg: ")[1];
            throw new verifiable_credential_1.ValidationError(`VP JWT validation failed: the VP JWT 'alg' header (${alg}) doesn't match the algorithm of the verification method related to the VP JWT 'kid' header`);
        }
        throw new verifiable_credential_1.ValidationError(`VP JWT validation failed: ${errorMessage}`);
    }
}
exports.validateSignature = validateSignature;
//# sourceMappingURL=validators.js.map