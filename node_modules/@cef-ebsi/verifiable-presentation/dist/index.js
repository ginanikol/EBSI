"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyPresentationJwt = exports.createVerifiablePresentationJwt = void 0;
const ebsi_did_resolver_1 = require("@cef-ebsi/ebsi-did-resolver");
const key_did_resolver_1 = require("@cef-ebsi/key-did-resolver");
const verifiable_credential_1 = require("@cef-ebsi/verifiable-credential");
const json_web_signature_1 = require("@transmute/json-web-signature");
const did_resolver_1 = require("did-resolver");
const jose_1 = require("jose");
const config_1 = require("./config");
const validators_1 = require("./validators");
__exportStar(require("./config"), exports);
__exportStar(require("./constants"), exports);
__exportStar(require("./types"), exports);
__exportStar(require("./validators"), exports);
/**
 * Creates a Verifiable Presentation JWT given an `EbsiVerifiablePresentation` and an `EbsiIssuer`.
 *
 * This method transforms the payload into the [JWT encoding](https://www.w3.org/TR/vc-data-model/#jwt-encoding)
 * described in the [W3C VC spec](https://www.w3.org/TR/vc-data-model) and then validated to conform to the EBSI
 * required spec.
 *
 * The `holder` is then used to assign an algorithm and sign the JWT.
 *
 * @param payload - `EbsiVerifiablePresentation`
 * @param holder - `EbsiIssuer` of the Presentation JWT (holder of the VC), signer and algorithm that will sign the token
 * @param audience - represents the identity of the intended audience (DID, URI)
 * @param options - `CreateVerifiablePresentationOptions` allows to pass additional values to the resulting JWT payload
 * @returns a `Promise` that resolves to the JWT encoded verifiable presentation or rejects with `ValidationError` if the
 * `payload` is not W3C compliant
 */
async function createVerifiablePresentationJwt(payload, holder, audience, options) {
    // Always verify that the payload is conform to the the Verifiable Presentation schema
    // EBSI_VP_001
    const { timeout, trustedHostnames } = options;
    (0, validators_1.validateEbsiVerifiablePresentation)(payload, timeout, trustedHostnames);
    const { skipValidation } = options;
    if (!skipValidation) {
        const { ebsiAuthority, ebsiEnvConfig } = options;
        const config = (0, config_1.mergeConfig)(ebsiAuthority, ebsiEnvConfig, trustedHostnames);
        (0, validators_1.validateContext)(payload["@context"]);
        (0, validators_1.validateType)(payload.type);
        const resolver = new did_resolver_1.Resolver({
            ...(0, ebsi_did_resolver_1.getLegacyResolver)({
                registry: config.didRegistry,
                naturalPersonJwks: [holder.publicKeyJwk],
            }),
            ...(0, key_did_resolver_1.getResolver)(),
        });
        // Validate VP holder
        await (0, validators_1.validateHolder)(payload, holder.did, holder.kid, resolver, options.proofPurpose, options.timeout);
        // If options.nbf or options.exp are provided, validate them
        if (options.nbf) {
            (0, validators_1.validateTimestamp)(options.nbf);
        }
        if (options.exp) {
            (0, validators_1.validateTimestamp)(options.exp);
        }
        // Validate VC JWTs
        await (0, validators_1.validateCredentials)(payload, holder.did, options);
    }
    else {
        (0, verifiable_credential_1.validateDid)(holder.did);
    }
    const decodedVcPayloads = payload.verifiableCredential.map((vcJwt) => (0, jose_1.decodeJwt)(vcJwt));
    // Prepare payload
    // See https://www.w3.org/TR/vc-data-model/#jwt-encoding
    const vpJwtPayload = {
        /**
         * `jti` MUST represent the `id` property of the verifiable presentation.
         */
        jti: typeof payload.id === "string" ? payload.id : "",
        /**
         * `sub` MUST represent the `id` property contained in the verifiable credential subject.
         */
        sub: holder.did,
        /**
         * `iss` MUST represent the issuer property of a verifiable credential.
         */
        iss: holder.did,
        /**
         * Time before which the Verifiable Presentation MUST NOT be accepted for processing.
         */
        nbf: options.nbf,
        /**
         * Expiration time after which the Verifiable Presentation MUST NOT be accepted for processing.
         */
        exp: options.exp,
        /**
         * Time at which the Verifiable Presentation has been issued.
         */
        iat: Math.floor(Date.now() / 1000),
        /**
         * `aud` MUST represent (i.e., identify) the intended audience of the verifiable presentation
         * (i.e., the verifier intended by the presenting holder to receive and verify the verifiable presentation).
         * @see https://www.w3.org/TR/vc-data-model/#jwt-encoding
         */
        aud: audience,
        /**
         * `nonce` can be used to prevent replay attacks, e.g. during a VP exchange.
         */
        nonce: options.nonce,
        /**
         * vp: JSON object, which MUST be present in a JWT verifiable presentation.
         * The object contains the verifiable presentation according to this specification.
         */
        vp: payload,
    };
    // Provide default nbf value if none was provided
    if (!vpJwtPayload.nbf) {
        // Extract "nbf" from VCs
        const vcNbf = decodedVcPayloads.map((vc) => vc.nbf || 0).filter((n) => n);
        // Assign VP nbf the highest nbf
        if (vcNbf.length > 0) {
            vpJwtPayload.nbf = Math.max(...vcNbf);
        }
    }
    // Provide default exp value if none was provided
    if (!vpJwtPayload.exp) {
        // Extract "exp" from VCs
        const vcExp = decodedVcPayloads.map((vc) => vc.exp || 0).filter((n) => n);
        // Assign VP exp the lowest exp
        if (vcExp.length > 0) {
            vpJwtPayload.exp = Math.min(...vcExp);
        }
        else {
            // Throw an error if no exp can be found
            throw new Error("The VP JWT requires an exp claim. Please provide one using the 'options' parameter.");
        }
    }
    // Add kid to JWT header
    const { kid, did, alg, publicKeyJwk, privateKeyJwk } = holder;
    const vpJwtHeader = {
        typ: "JWT",
        kid,
        ...((0, validators_1.isLegacyNaturalPersonDid)(holder.did) && {
            jwk: publicKeyJwk,
        }),
        alg,
    };
    const holderKey = {
        id: kid,
        type: "JsonWebKey2020",
        controller: did,
        publicKeyJwk,
        privateKeyJwk,
    };
    const signingKey = (await json_web_signature_1.JsonWebKey.from(holderKey));
    const vpKey = (await json_web_signature_1.JsonWebKey.from(
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-expect-error
    // eslint-disable-next-line @typescript-eslint/no-unsafe-call
    (await signingKey.export({
        type: "JsonWebKey2020",
        privateKey: true,
    })), {
        detached: false,
        header: vpJwtHeader,
    }));
    const vpSigner = vpKey.signer();
    const vpJwt = await vpSigner.sign({ data: vpJwtPayload });
    return vpJwt;
}
exports.createVerifiablePresentationJwt = createVerifiablePresentationJwt;
/**
 * Verifies and validates an EBSI Verifiable Presentation that is encoded as a JWT according to the EBSI and W3C specs.
 *
 * @param presentation - the presentation to be verified. Currently only the JWT encoding is supported by this library
 * @param audience - represents the identity of the intended audience (DID, URI)
 * @param options - optional verification options that need to be satisfied
 * @returns a `Promise` that resolves to a `VerifiedPresentation` or rejects with `ValidationError` if the input is
 * not EBSI compliant or the VerifyPresentationJwtOptions are not satisfied.
 */
async function verifyPresentationJwt(presentation, audience, options) {
    const { ebsiAuthority, ebsiEnvConfig, timeout, trustedHostnames } = options;
    const config = (0, config_1.mergeConfig)(ebsiAuthority, ebsiEnvConfig, trustedHostnames);
    // EBSI_JWT_VP_001
    const { header, payload } = (0, validators_1.validateJwtProps)(presentation, audience, options);
    const resolver = new did_resolver_1.Resolver({
        ...(0, ebsi_did_resolver_1.getLegacyResolver)({
            registry: config.didRegistry,
            naturalPersonJwks: [header.jwk],
        }),
        ...(0, key_did_resolver_1.getResolver)(),
    });
    if (!options.skipSignatureValidation) {
        // EBSI_JWT_VP_005
        await (0, validators_1.validateSignature)(presentation, resolver, {
            timeout,
        });
    }
    const { kid = "" } = header;
    const { iss = "" } = payload;
    const { vp } = payload;
    (0, validators_1.validateContext)(vp["@context"]);
    (0, validators_1.validateType)(vp.type);
    // Validate VP holder
    await (0, validators_1.validateHolder)(vp, iss, kid, resolver, options.proofPurpose, timeout, options.skipHolderDidResolutionValidation);
    // Validate VC JWTs
    await (0, validators_1.validateCredentials)(vp, iss, options);
    return vp;
}
exports.verifyPresentationJwt = verifyPresentationJwt;
//# sourceMappingURL=index.js.map