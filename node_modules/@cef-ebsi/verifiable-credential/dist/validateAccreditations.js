"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateAccreditations = exports.validateIssuerCanSelfAttestForTrustChain = exports.isSelfAttestationForTrustChain = void 0;
const jose_1 = require("jose");
const constants_1 = require("./constants");
const utils_1 = require("./utils");
/**
 * Function to get a credential (attribute) from
 * the Trusted Issuers Registry
 * @returns the payload of the credential
 */
async function getCredential(url, options) {
    try {
        const response = await (0, utils_1.memGet)(url, options?.timeout);
        if (!response.data ||
            !response.data.attribute ||
            !response.data.attribute.body) {
            throw new Error("No attribute in the response");
        }
        if (response.data.attribute.issuerType === "Revoked") {
            throw new Error("Revoked");
        }
        const { vc } = (0, jose_1.decodeJwt)(response.data.attribute.body);
        if (!vc)
            throw new Error("vc field not found");
        return vc;
    }
    catch (error) {
        throw new Error(`Invalid credential ${url}: ${(0, utils_1.getErrorMessage)(error)}`);
    }
}
/**
 * Function to get missing types of an accreditation
 * @param types - list of types to validate
 * @param accreditorTypes - list of types found in the accreditor
 * @returns the list of types that are not fulfilled by "accreditorTypes"
 */
function getMissingTypes(types, accreditorTypes) {
    if (accreditorTypes.includes("VerifiableAuthorisationForTrustChain")) {
        // the root of trust chain allows any type in the credential
        // then an empty array is returned as all types are fulfilled
        return [];
    }
    const accreditorIsTI = accreditorTypes.includes("VerifiableAccreditationToAttest");
    const accreditorIsTAO = accreditorTypes.includes("VerifiableAccreditationToAccredit");
    const missingTypes = [];
    types.forEach((t) => {
        // do not include the types already present in the accreditor
        if (accreditorTypes.includes(t))
            return;
        // the authorisation to onboard is implicit for TIs and TAOs
        if (t === "VerifiableAuthorisationToOnboard" &&
            (accreditorIsTI || accreditorIsTAO))
            return;
        // the accreditation to attest is implicit for TAOs
        if (t === "VerifiableAccreditationToAttest" && accreditorIsTAO)
            return;
        // include the missing type
        missingTypes.push(t);
    });
    return missingTypes;
}
/**
 * Function to determine if a VC is self attesting an accreditation
 * to issue credentials with type "VerifiableAuthorisationForTrustChain".
 * This self accreditation is done by Support Office.
 *
 * It requires in the VC:
 * - $.type to contain "VerifiableAccreditationToAttest"
 * - $.credentialSubject.accreditedFor to contain "VerifiableAuthorisationForTrustChain"
 */
function isSelfAttestationForTrustChain(vcPayload) {
    const { type, credentialSubject } = vcPayload;
    if (!Array.isArray(type) || !credentialSubject)
        return false;
    if (vcPayload.issuer !== vcPayload.credentialSubject.id)
        return false;
    if (!type.includes("VerifiableAccreditationToAttest"))
        return false;
    const { accreditedFor } = credentialSubject;
    if (!accreditedFor || !Array.isArray(accreditedFor))
        return false;
    return accreditedFor.some((accreditedForValue) => accreditedForValue &&
        typeof accreditedForValue === "object" &&
        "types" in accreditedForValue &&
        Array.isArray(accreditedForValue.types) &&
        accreditedForValue.types.includes("VerifiableAuthorisationForTrustChain"));
}
exports.isSelfAttestationForTrustChain = isSelfAttestationForTrustChain;
/**
 * Function to check in the Trusted Policies Registry if an issuer
 * has TIR Admin rights to create/update issuers. So, this user can
 * self attest to issue VerifiableAuthorisationForTrustChain
 */
async function validateIssuerCanSelfAttestForTrustChain(vcPayload, config) {
    try {
        const didResponse = await (0, utils_1.memGet)(`${config.didRegistry}/${vcPayload.issuer}`);
        const ethAddresses = didResponse.data.verificationMethod
            ?.map((vMethod) => {
            if (!vMethod.publicKeyJwk)
                return "";
            return (0, utils_1.getEthereumAddress)(vMethod.publicKeyJwk);
        })
            .filter(Boolean) || [];
        if (ethAddresses.length === 0)
            throw new Error("Did document without verification methods using crv secp256k1");
        const errorMessages = [];
        /* eslint-disable no-await-in-loop */
        for (let i = 0; i < ethAddresses.length; i += 1) {
            const address = ethAddresses[i];
            try {
                // get user from TPR
                const tprResponse = await (0, utils_1.memGet)(`${config.trustedPoliciesRegistry}/${address}`);
                // check if it contains admin attributes for TIR
                const adminAttribute = Object.keys(tprResponse.data.attributes).find((attrId) => {
                    const attr = Number(tprResponse.data.attributes[attrId]);
                    return (constants_1.acceptedTrustedPoliciesRegistryAttributes.includes(attrId) && attr);
                });
                if (adminAttribute)
                    return;
                throw new Error(`the address ${address} doesn't have one of these attributes ${constants_1.acceptedTrustedPoliciesRegistryAttributes.join(",")} in the Trusted Policies Registry`);
            }
            catch (error) {
                errorMessages.push((0, utils_1.getErrorMessage)(error));
            }
        }
        /* eslint-enable no-await-in-loop */
        throw new Error(JSON.stringify(errorMessages));
    }
    catch (error) {
        throw new Error(`Invalid self attestation of ${vcPayload.issuer} to issue credentials for VerifiableAuthorisationForTrustChain: ${(0, utils_1.getErrorMessage)(error)}`);
    }
}
exports.validateIssuerCanSelfAttestForTrustChain = validateIssuerCanSelfAttestForTrustChain;
/**
 * Function to validate if a verifiable credential has the correct
 * trust chain of accreditations in the Trusted Issuers Registry
 */
async function validateAccreditations(vcPayload, options) {
    const { issuer } = vcPayload;
    let { termsOfUse } = vcPayload;
    const { type, credentialSubject } = vcPayload;
    let typesSubject = [...new Set(type)];
    if (!termsOfUse) {
        if (!options?.validateAccreditationWithoutTermsOfUse) {
            // Exit early if there is no termsOfUse to validate
            return;
        }
        if (isSelfAttestationForTrustChain(vcPayload)) {
            // it is a self attestation to issue credentials with type
            // VerifiableAuthorisationForTrustChain
            if (!options || !options.ebsiEnvConfig) {
                throw new Error("ebsiEnvConfig not defined to validate self attest for trust chain");
            }
            await validateIssuerCanSelfAttestForTrustChain(vcPayload, options?.ebsiEnvConfig);
            return;
        }
        throw new Error("Credential doesn't contain terms of use");
    }
    if (!Array.isArray(termsOfUse)) {
        termsOfUse = [termsOfUse];
    }
    // include in typesSubject the types defined in accreditedFor
    if (credentialSubject && credentialSubject.accreditedFor) {
        const { accreditedFor } = credentialSubject;
        accreditedFor.forEach((af) => {
            typesSubject.push(...af.types);
        });
        typesSubject = [...new Set(typesSubject)];
    }
    let missingTypes = typesSubject;
    await Promise.all(termsOfUse.map(async (t) => {
        if (!t.id)
            return;
        // termsOfUse must be IssuanceCertificate
        if (t.type !== "IssuanceCertificate")
            throw new Error("Terms of use must be of type IssuanceCertificate");
        // the link in termsOfUse should point to an attribute of the issuer
        const idParts = t.id.split("/");
        if (issuer !== idParts[idParts.length - 3]) {
            throw new Error(`Issuer ${issuer} not found in the termsOfUse`);
        }
        // get the accreditation of the issuer
        const accreditation = await getCredential(t.id, options);
        // check which "types" the issuer is allowed to issue
        // by checking accreditation.type
        if (accreditation.type)
            missingTypes = getMissingTypes(missingTypes, accreditation.type);
        // check which "types" the issuer is allowed to issue
        // by checking accreditation.credentialSubject.accreditedFor
        if (accreditation.credentialSubject &&
            accreditation.credentialSubject.accreditedFor) {
            const { accreditedFor } = accreditation.credentialSubject;
            accreditedFor.forEach((af) => {
                if (af.types)
                    missingTypes = getMissingTypes(missingTypes, af.types);
            });
        }
    }));
    // check if there were types to accredit
    if (missingTypes.length > 0) {
        throw new Error(`Issuer ${issuer} is not accredited to issue credentials with type ${JSON.stringify(missingTypes)}`);
    }
}
exports.validateAccreditations = validateAccreditations;
//# sourceMappingURL=validateAccreditations.js.map