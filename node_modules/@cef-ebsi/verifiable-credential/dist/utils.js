"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getErrorMessage = exports.getEthereumAddress = exports.getPublicKeyHex = exports.memGet = exports.AXIOS_TIMEOUT = void 0;
const mem_1 = __importDefault(require("mem"));
const axios_1 = __importDefault(require("axios"));
const elliptic_1 = require("elliptic");
const ethers_1 = require("ethers");
const base64_1 = require("multiformats/bases/base64");
exports.AXIOS_TIMEOUT = 15000;
// Cache Axios GET requests for 5 minutes
const GET_MAX_AGE = 5 * 60 * 1000;
const get = (url, timeout) => {
    return axios_1.default.get(url, {
        timeout: timeout ?? exports.AXIOS_TIMEOUT,
    });
};
exports.memGet = (0, mem_1.default)(get, { maxAge: GET_MAX_AGE });
function getPublicKeyHex(jwk) {
    if (jwk.crv !== "secp256k1" || !jwk.x || !jwk.y)
        return "";
    const ec = new elliptic_1.ec("secp256k1");
    const publicKey = ec.keyFromPublic({
        x: Buffer.from(base64_1.base64url.baseDecode(jwk.x)).toString("hex"),
        y: Buffer.from(base64_1.base64url.baseDecode(jwk.y)).toString("hex"),
    });
    return `0x${publicKey.getPublic().encode("hex", false)}`;
}
exports.getPublicKeyHex = getPublicKeyHex;
function getEthereumAddress(jwk) {
    const publicKeyHex = getPublicKeyHex(jwk);
    if (!publicKeyHex)
        return "";
    return ethers_1.ethers.utils.computeAddress(publicKeyHex);
}
exports.getEthereumAddress = getEthereumAddress;
function getErrorMessage(error) {
    if (!(error instanceof Error)) {
        return "unknown error";
    }
    if (!axios_1.default.isAxiosError(error)) {
        return error.message;
    }
    if (!error.response || !error.response.data) {
        return error.message;
    }
    if (typeof error.response.data === "string") {
        return error.response.data;
    }
    if (typeof error.response.data !== "object") {
        return "unknown error";
    }
    const { data } = error.response;
    if ("detail" in data && typeof data.detail === "string") {
        return data.detail;
    }
    if ("title" in data && typeof data.title === "string") {
        return data.title;
    }
    return JSON.stringify(data);
}
exports.getErrorMessage = getErrorMessage;
//# sourceMappingURL=utils.js.map