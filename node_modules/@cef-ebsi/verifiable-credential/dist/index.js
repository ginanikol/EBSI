"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyCredentialJwt = exports.createVerifiableCredentialJwt = void 0;
const json_web_signature_1 = require("@transmute/json-web-signature");
const validators_1 = require("./validators");
const config_1 = require("./config");
const validateAccreditations_1 = require("./validateAccreditations");
__exportStar(require("./config"), exports);
__exportStar(require("./constants"), exports);
__exportStar(require("./contexts"), exports);
__exportStar(require("./types"), exports);
__exportStar(require("./errors"), exports);
__exportStar(require("./utils"), exports);
__exportStar(require("./validators"), exports);
__exportStar(require("./validateAccreditations"), exports);
/**
 * Creates a VerifiableCredential given an `EbsiVerifiableAttestation` and an `EbsiIssuer`.
 *
 * This method transforms the payload into the [JWT encoding](https://www.w3.org/TR/vc-data-model/#jwt-encoding)
 * described in the [W3C VC spec](https://www.w3.org/TR/vc-data-model).
 *
 * The `issuer` is then used to assign an algorithm, and then sign the JWT.
 *
 * @param payload - `EbsiVerifiableAttestation`
 * @param issuer - `EbsiIssuer`: the DID, kid, signer and algorithm that will sign the token
 * @returns a `Promise` that resolves to the JWT encoded verifiable credential or rejects with
 * `ValidationError` if the `payload` is not EBSI compliant
 */
async function createVerifiableCredentialJwt(payload, issuer, options) {
    // Always verify that the payload is conform to the the Verifiable Attestation schemas
    const { timeout, trustedHostnames } = options;
    (0, validators_1.validateEbsiVerifiableAttestation)(payload, timeout, trustedHostnames);
    const { skipValidation } = options;
    if (!skipValidation) {
        const { ebsiAuthority, ebsiEnvConfig, skipAccreditationsValidation, skipStatusValidation, } = options;
        const config = (0, config_1.mergeConfig)(ebsiAuthority, ebsiEnvConfig, trustedHostnames);
        (0, validators_1.validateContext)(payload["@context"]);
        (0, validators_1.validateType)(payload.type);
        (0, validators_1.validateDates)(payload);
        (0, validators_1.validateCredentialSubject)(payload);
        await (0, validators_1.validateIssuer)(payload, issuer.did, issuer.kid, config, timeout);
        await (0, validators_1.validateCredentialSchema)(payload, timeout, trustedHostnames);
        if (!skipAccreditationsValidation) {
            await (0, validateAccreditations_1.validateAccreditations)(payload, options);
        }
        if (!skipStatusValidation) {
            await (0, validators_1.validateCredentialStatus)(payload, config, options);
        }
    }
    const credentialIssuer = payload.issuer;
    const subject = payload.credentialSubject.id;
    const validFrom = payload.validFrom || payload.issuanceDate;
    const { expirationDate } = payload;
    // Prepare payload
    // See https://www.w3.org/TR/vc-data-model/#jwt-encoding
    const vcJwtPayload = {
        /**
         * `jti` MUST represent the `id` property of the verifiable credential.
         */
        jti: payload.id,
        /**
         * `sub` MUST represent the `id` property contained in the verifiable credential subject.
         */
        sub: subject ?? "",
        /**
         * `iss` MUST represent the issuer property of a verifiable credential.
         */
        iss: credentialIssuer,
        /**
         * `nbf` MUST represent `issuanceDate`, encoded as a UNIX timestamp.
         *
         * Note: since `validFrom` will replace `issuanceDate` in the future, we support both.
         */
        ...(validFrom && {
            nbf: Math.floor(Date.parse(validFrom) / 1000),
        }),
        /**
         * `exp` MUST represent the `expirationDate` property, encoded as a UNIX timestamp.
         */
        ...(expirationDate && {
            exp: Math.floor(Date.parse(expirationDate) / 1000),
        }),
        /**
         * Time at which the VC JWT was issued.
         */
        iat: Math.floor(Date.parse(payload.issued) / 1000),
        /**
         * vc: JSON object, which MUST be present in a JWT verifiable credential.
         * The object contains the verifiable credential according to this specification.
         */
        vc: payload,
    };
    // Add kid to JWT header
    const { kid } = issuer;
    const vcJwtHeader = {
        typ: "JWT",
        kid,
        alg: issuer.alg,
    };
    const issuerKey = {
        id: issuer.kid,
        type: "JsonWebKey2020",
        controller: issuer.did,
        publicKeyJwk: issuer.publicKeyJwk,
        privateKeyJwk: issuer.privateKeyJwk,
    };
    const signingKey = (await json_web_signature_1.JsonWebKey.from(issuerKey));
    const vcKey = (await json_web_signature_1.JsonWebKey.from(
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    // eslint-disable-next-line @typescript-eslint/no-unsafe-call
    (await signingKey.export({
        type: "JsonWebKey2020",
        privateKey: true,
    })), {
        detached: false,
        header: vcJwtHeader,
    }));
    const signer = vcKey.signer();
    // Create JWT
    const vcJwt = await signer.sign({ data: vcJwtPayload });
    return vcJwt;
}
exports.createVerifiableCredentialJwt = createVerifiableCredentialJwt;
/**
 * Verifies and validates a VerifiableCredential that is encoded as a JWT according to the W3C and EBSI specs.
 *
 * @param vc - the credential to be verified.
 * @returns a `Promise` that resolves to a `VerifiedCredential` or rejects with `ValidationError` if the input is not EBSI compliant
 */
async function verifyCredentialJwt(vc, options) {
    const config = (0, config_1.mergeConfig)(options.ebsiAuthority, options.ebsiEnvConfig, options.trustedHostnames);
    return (0, validators_1.verifyVcJwt)(vc, config, options);
}
exports.verifyCredentialJwt = verifyCredentialJwt;
//# sourceMappingURL=index.js.map