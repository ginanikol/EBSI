"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyVcJwt = exports.validateJwtProps = exports.validateCredentialStatus = exports.validateEbsiAccreditationEntry = exports.validateStatusList2021Entry = exports.validateType = exports.validateContext = exports.validateDates = exports.validateCredentialSchema = exports.validateCredentialSubject = exports.validateIssuer = exports.validateDid = exports.validateLegalEntityDid = exports.validateEbsiVerifiableAttestation = exports.getAjvInstance = exports.handleDidResolutionErrors = exports.validateTrustedSchemasRegistryUrl = exports.validateTrustedSchemasRegistryUrlHostname = exports.validateTrustedSchemasRegistryUrlPathname = exports.validateHostname = void 0;
const jose_1 = require("jose");
const ebsi_did_resolver_1 = require("@cef-ebsi/ebsi-did-resolver");
const key_did_resolver_1 = require("@cef-ebsi/key-did-resolver");
const json_web_signature_1 = require("@transmute/json-web-signature");
const vc_js_1 = require("@transmute/vc.js");
const did_resolver_1 = require("did-resolver");
const _2020_1 = __importDefault(require("ajv/dist/2020"));
const ajv_formats_1 = __importDefault(require("ajv-formats"));
const mem_1 = __importDefault(require("mem"));
const axios_1 = __importDefault(require("axios"));
const base64_1 = require("multiformats/bases/base64");
const base16_1 = require("multiformats/bases/base16");
const pako_1 = require("pako");
const schema_json_1 = __importDefault(require("./schemas/ebsi-attestation/2022-11_01/schema.json"));
const errors_1 = require("./errors");
const constants_1 = require("./constants");
const utils_1 = require("./utils");
const validateAccreditations_1 = require("./validateAccreditations");
const contexts_1 = require("./contexts");
function validateHostname(hostname, trustedHostnames) {
    const validHostnames = [
        "localhost",
        ...(trustedHostnames && trustedHostnames.length > 0
            ? trustedHostnames
            : ["api-test.ebsi.eu", "api-conformance.ebsi.eu", "api-pilot.ebsi.eu"]),
    ];
    // Matches exactly one of the valid domains
    if (validHostnames.includes(hostname)) {
        return;
    }
    throw new errors_1.ValidationError(`Invalid hostname ${hostname}`);
}
exports.validateHostname = validateHostname;
function validateTrustedSchemasRegistryUrlPathname(pathname) {
    if (!/^\/trusted-schemas-registry\/v\d+\/schemas\//.test(pathname)) {
        throw new errors_1.ValidationError(`${pathname} does not belong to Trusted Schemas Registry`);
    }
}
exports.validateTrustedSchemasRegistryUrlPathname = validateTrustedSchemasRegistryUrlPathname;
function validateTrustedSchemasRegistryUrlHostname(hostname, trustedHostnames) {
    try {
        validateHostname(hostname, trustedHostnames);
    }
    catch (e) {
        throw new errors_1.ValidationError(`${hostname} is not a trusted hostname`);
    }
}
exports.validateTrustedSchemasRegistryUrlHostname = validateTrustedSchemasRegistryUrlHostname;
function validateTrustedSchemasRegistryUrl(url, trustedHostnames) {
    try {
        let hostname = "";
        let pathname = "";
        try {
            const urlObject = new URL(url);
            hostname = urlObject.hostname;
            pathname = urlObject.pathname;
        }
        catch (e) {
            throw new errors_1.ValidationError("unable to parse URL");
        }
        validateTrustedSchemasRegistryUrlHostname(hostname, trustedHostnames);
        validateTrustedSchemasRegistryUrlPathname(pathname);
    }
    catch (error) {
        if (error instanceof Error) {
            throw new errors_1.ValidationError(`Invalid Schema URL "${url}". Reason: ${error.message}`);
        }
        throw error;
    }
}
exports.validateTrustedSchemasRegistryUrl = validateTrustedSchemasRegistryUrl;
// Load remote schemas with Axios
function loadSchema(timeout, trustedHostnames) {
    return async (url) => {
        validateTrustedSchemasRegistryUrl(url, trustedHostnames);
        const { data: schema } = await (0, utils_1.memGet)(url, timeout);
        return schema;
    };
}
function handleDidResolutionErrors(didDocument, didResolutionMetadata, did) {
    if (!didDocument) {
        let errorMessage = `Unable to resolve ${did}. Error: ${didResolutionMetadata.error || "unknown"}`;
        if (typeof didResolutionMetadata.message === "string") {
            errorMessage += `. ${didResolutionMetadata.message}`;
        }
        throw new errors_1.ValidationError(errorMessage);
    }
}
exports.handleDidResolutionErrors = handleDidResolutionErrors;
exports.getAjvInstance = (0, mem_1.default)((timeout, trustedHostnames) => {
    // Configure Ajv
    const ajv = new _2020_1.default({
        allErrors: true,
        loadSchema: loadSchema(timeout, trustedHostnames),
    });
    // JSON Schema formats for Ajv
    (0, ajv_formats_1.default)(ajv);
    // Pre-register EBSI Verifiable Attestation 2022-11_01 schema
    ajv.addSchema(schema_json_1.default, constants_1.EBSI_VERIFIABLE_ATTESTATION_SCHEMA_ID_HEX);
    ajv.addSchema(schema_json_1.default, constants_1.EBSI_VERIFIABLE_ATTESTATION_SCHEMA_ID_MULTIBASE_BASE58BTC);
    return ajv;
});
/**
 * EBSI_VC_001: All the EBSI Verifiable Credentials MUST be conform to the Verifiable Attestation model.
 *
 * Validates that the given value is an EbsiVerifiableAttestation object.
 *
 * @param value - any value
 * @param timeout - Axios requests timeout. Default: 15 seconds
 * @param trustedHostnames - List of additional trusted hostnames running the EBSI Core Services APIs.
 */
function validateEbsiVerifiableAttestation(value, timeout, trustedHostnames) {
    const ajv = (0, exports.getAjvInstance)(timeout, trustedHostnames);
    const validate = ajv.getSchema(constants_1.EBSI_VERIFIABLE_ATTESTATION_SCHEMA_ID_HEX);
    if (!validate) {
        throw new errors_1.JsonSchemaLoadingError("Unable to get EBSI VA schema");
    }
    const valid = validate(value);
    if (!valid && validate.errors) {
        throw new errors_1.JsonSchemaValidationError("Invalid EBSI Verifiable Attestation", validate.errors);
    }
}
exports.validateEbsiVerifiableAttestation = validateEbsiVerifiableAttestation;
/**
 * Validates that the given value is a well-formatted Legal Entity EBSI DID.
 * Throws a `ValidationError` if it is not.
 *
 * Note: this function doesn't check if the DID is registered in the DID Registry.
 *
 * @param value - any value
 */
function validateLegalEntityDid(value) {
    if (typeof value !== "string") {
        throw new errors_1.ValidationError("The DID must be a string");
    }
    let version;
    try {
        // Use @cef-ebsi/ebsi-did-resolver validator
        version = (0, ebsi_did_resolver_1.validate)(value);
    }
    catch (e) {
        throw new errors_1.ValidationError(e instanceof Error ? e.message : `${value} is not a valid EBSI DID`);
    }
    if (version !== ebsi_did_resolver_1.EBSI_DID_SPECS.LEGAL_ENTITY.VERSION_ID) {
        throw new errors_1.ValidationError(`The DID method version ${version} of the DID ${value} does not correspond to the version ${ebsi_did_resolver_1.EBSI_DID_SPECS.LEGAL_ENTITY.VERSION_ID} of Legal Entities`);
    }
}
exports.validateLegalEntityDid = validateLegalEntityDid;
/**
 * Validates that the given value is a well-formatted EBSI DID (Legal Entity or Natural Person).
 * Throws a `ValidationError` if it is not.
 *
 * Note: this function doesn't check if the DID is registered in the DID Registry.
 *
 * @param value - any value
 * @param allowLegacyEbsiMethodV2 - if true (default), allows the legacy EBSI DID method v2. Will be removed in the future.
 */
function validateDid(value, allowLegacyEbsiMethodV2 = true) {
    if (typeof value !== "string") {
        throw new errors_1.ValidationError("The DID must be a string");
    }
    try {
        if (value.startsWith(ebsi_did_resolver_1.EBSI_DID_METHOD_PREFIX)) {
            if (allowLegacyEbsiMethodV2) {
                // Use @cef-ebsi/ebsi-did-resolver validator
                (0, ebsi_did_resolver_1.validate)(value);
            }
            else {
                validateLegalEntityDid(value);
            }
        }
        else if (value.startsWith(key_did_resolver_1.KEY_DID_METHOD_PREFIX)) {
            // Use @cef-ebsi/key-did-resolver validator
            key_did_resolver_1.util.validateDid(value);
        }
        else {
            throw new Error(`The DID must start with "${ebsi_did_resolver_1.EBSI_DID_METHOD_PREFIX}" or "${key_did_resolver_1.KEY_DID_METHOD_PREFIX}"`);
        }
    }
    catch (e) {
        throw new errors_1.ValidationError(e instanceof Error ? e.message : `${value} is not a valid EBSI DID`);
    }
}
exports.validateDid = validateDid;
/**
 * Validates the credential issuer.
 *
 * Rules:
 * - EBSI_VC_005: `payload.issuer` MUST contain a valid EBSI DID
 * - both DIDs (`payload.issuer` and `did`) MUST match
 * - the issuer `kid` MUST be related to the issuer DID (starts with the issuer DID)
 * - the issuer DID MUST resolve to a valid DID document
 * - `kid` MUST be a valid verification method in the DID document
 * - EBSI_VC_006: the issuer MUST be registered in the Trusted Issuers Registry
 *
 * @param payload - `EbsiVerifiableAttestation`
 * @param did - the DID of the credential signer
 * @param kid - the kid identifying the verification method used to sign the JWT
 * @param config - a configuration object containing the URLs to the DID Registry and Trusted Issuers Registry
 * @param skipValidation - set to true to skip the dynamic validation (i.e. checking against DID Registry / Trusted Issuers Registry)
 * @param timeout - Axios requests timeout. Default: 15 seconds
 */
async function validateIssuer(payload, did, kid, config, timeout = utils_1.AXIOS_TIMEOUT) {
    const credentialIssuer = payload.issuer;
    validateDid(credentialIssuer, false);
    // Make sure the DIDs match
    if (credentialIssuer !== did) {
        throw new errors_1.ValidationError(`payload.issuer "${credentialIssuer}" and did "${did}" don't match`);
    }
    // Validate kid
    if (typeof kid !== "string") {
        throw new errors_1.ValidationError("kid is required");
    }
    if (kid.indexOf("#") === -1) {
        throw new errors_1.ValidationError(`kid doesn't contain "#"`);
    }
    if (kid.split("#")[0] !== credentialIssuer) {
        throw new errors_1.ValidationError("did and kid don't match");
    }
    // Verify that the DID document can be resolved
    // TODO: support did:key
    const resolver = new did_resolver_1.Resolver({
        ...(0, ebsi_did_resolver_1.getResolver)({ registry: config.didRegistry }),
        ...(0, key_did_resolver_1.getResolver)(),
    });
    const { didDocument, didResolutionMetadata } = await resolver.resolve(credentialIssuer, { timeout });
    handleDidResolutionErrors(didDocument, didResolutionMetadata, credentialIssuer);
    // Check "assertionMethod" verification relationship
    const verificationMethods = didDocument.assertionMethod || [];
    if (!verificationMethods?.find((method) => {
        if (typeof method === "string") {
            return method === kid;
        }
        return method.id === kid;
    })) {
        throw new errors_1.ValidationError(`Could not find a verification method related to "${kid}"`);
    }
    // TODO: is this really necessary?
    // Reason: what really matters is the accreditation, not the fact to be registered in the TIR
    const isLegalEntity = credentialIssuer.startsWith(ebsi_did_resolver_1.EBSI_DID_METHOD_PREFIX);
    if (isLegalEntity) {
        // EBSI_VC_006: Verify that the issuer is registered in the Trusted Issuers Registry
        try {
            await (0, utils_1.memGet)(`${config.trustedIssuersRegistry}/${credentialIssuer}`, timeout);
        }
        catch (e) {
            throw new errors_1.ValidationError(`"${credentialIssuer}" is not a trusted issuer (${config.trustedIssuersRegistry})`);
        }
    }
}
exports.validateIssuer = validateIssuer;
/**
 * Validates the Verifiable Credential `credentialSubject` property.
 *
 * Rules:
 * - The credential subject must be a valid EBSI DID except when the credential type is `StatusList2021Credential`.
 *
 * Note: we don't support multiple credential subjects.
 *
 *   "Implementers are warned that JWTs are not capable of encoding multiple subjects and are
 *    thus not capable of encoding a verifiable credential with more than one subject."
 *
 * See https://www.w3.org/TR/vc-data-model/#jwt-encoding
 *
 * @param payload - `EbsiVerifiableAttestation`
 */
function validateCredentialSubject(payload) {
    // Do not validate the credentialSubject of a StatusList2021Credential
    if (payload.type.includes("StatusList2021Credential")) {
        return;
    }
    const subject = payload.credentialSubject.id;
    // Accept both EBSI DID method v1 and v2
    validateDid(subject);
}
exports.validateCredentialSubject = validateCredentialSubject;
/**
 * Validates the credential payload according to its schema, as defined in `payload.credentialSchema`.
 *
 * Rules:
 * - EBSI_VC_002: validate the payload with the custom JSON schema defined in credentialSchema.id.
 *   Only schemas from trusted sources are allowed.
 *
 * Notes:
 * - make sure to run `validateEbsiVerifiableAttestation` on the payload before calling `validateDates`.
 *
 * @param payload - `EbsiVerifiableAttestation`
 * @param timeout - Axios requests timeout. Default: 15 seconds
 * @param trustedHostnames - List of additional trusted hostnames running the EBSI Core Services APIs.
 */
async function validateCredentialSchema(payload, timeout, trustedHostnames) {
    const { credentialSchema } = payload;
    const ajv = (0, exports.getAjvInstance)(timeout, trustedHostnames);
    const schemaIds = Array.isArray(credentialSchema)
        ? credentialSchema.map((credSchema) => credSchema.id)
        : [credentialSchema.id];
    if (schemaIds.length === 0 || schemaIds.filter(Boolean).length === 0) {
        throw new errors_1.ValidationError("Can't extract schema ID from credentialSchema");
    }
    // Validate all credentialSchema
    await Promise.all(schemaIds.map(async (originalSchemaId) => {
        const schemaId = originalSchemaId.split("/").pop();
        if (!schemaId) {
            throw new errors_1.ValidationError(`Can't extract schema ID from "${originalSchemaId}"`);
        }
        try {
            if (!ajv.getSchema(schemaId)) {
                const trustedSchema = await loadSchema(timeout, trustedHostnames)(originalSchemaId);
                // Run compileAsync to get all referenced schemas
                await ajv.compileAsync(trustedSchema);
                // Add schema to cache
                ajv.addSchema(trustedSchema, schemaId);
            }
        }
        catch (e) {
            if (e instanceof errors_1.ValidationError) {
                throw e;
            }
            throw new errors_1.ValidationError(`JSON schema "${originalSchemaId}" not found. Reason: ${e.message}`);
        }
        const validate = ajv.getSchema(schemaId);
        if (!validate) {
            throw new errors_1.JsonSchemaLoadingError(`Unable to get JSON schema "${originalSchemaId}"`);
        }
        // Validate the full payload
        if (!validate(payload)) {
            throw new errors_1.JsonSchemaValidationError("Invalid VC payload", validate.errors || []);
        }
    }));
}
exports.validateCredentialSchema = validateCredentialSchema;
/**
 * Validates the Verifiable Credential dates: `issuanceDate`/`validFrom`, `expirationDate`.
 *
 * Rules:
 * - EBSI_VC_003: `issuanceDate` and `validFrom` MUST be equal.
 * - EBSI_VC_004: `issuanceDate`/`validFrom` must be less than `expirationDate` (if defined)
 *
 * Notes:
 * - make sure to run `validateEbsiVerifiableAttestation` on the payload before calling `validateDates`.
 * - this function does NOT verify if the VC is valid at the current time. It only compares the
 *   provided dates.
 *
 * @param payload - `EbsiVerifiableAttestation`
 */
function validateDates(payload, validAt) {
    // EBSI_VC_003
    if (payload.validFrom !== payload.issuanceDate) {
        throw new errors_1.ValidationError("validFrom and issuanceDate MUST have the same value when they are both defined");
    }
    // EBSI_VC_004
    if (payload.expirationDate &&
        Date.parse(payload.expirationDate) < Date.parse(payload.validFrom)) {
        throw new errors_1.ValidationError("expirationDate MUST be more recent than validFrom");
    }
    // EBSI_VC_008
    if (validAt) {
        if (payload.validFrom &&
            Math.floor(Date.parse(payload.validFrom) / 1000) > validAt) {
            throw new errors_1.ValidationError(`The Credential is not valid before: ${payload.validFrom}`);
        }
        if (payload.expirationDate &&
            validAt > Math.floor(Date.parse(payload.expirationDate) / 1000)) {
            throw new errors_1.ValidationError(`The Credential is not valid after: ${payload.expirationDate}`);
        }
    }
}
exports.validateDates = validateDates;
/**
 * Validates that the '\@context' is conform to the W3C specs.
 *
 * @param context - a set of URIs to validate
 */
function validateContext(context) {
    if (!Array.isArray(context)) {
        throw new errors_1.ValidationError('"@context" must be an array of strings');
    }
    if (context[0] !== "https://www.w3.org/2018/credentials/v1") {
        throw new errors_1.ValidationError('The first URI in "@context" must be "https://www.w3.org/2018/credentials/v1"');
    }
}
exports.validateContext = validateContext;
/**
 * Validates that the 'type' is conform to the W3C specs.
 *
 * @param type - a set of types to validate
 */
function validateType(type) {
    if (!Array.isArray(type)) {
        throw new errors_1.ValidationError('"type" must be an array of strings');
    }
    if (type[0] !== "VerifiableCredential") {
        throw new errors_1.ValidationError('The first type must be "VerifiableCredential"');
    }
}
exports.validateType = validateType;
/**
 * Validates that the StatusList2021Entry credential is not revoked nor suspended.
 *
 * @see https://w3c.github.io/vc-status-list-2021/
 *
 * @param credentialStatus - the credentialStatus object to validate
 * @param config - a configuration object containing the URLs to the Trusted Issuers Registry
 * @param options - a configuration object containing the timeout for the HTTP requests
 */
async function validateStatusList2021Entry(credentialStatus, config, options) {
    if (credentialStatus.type !== "StatusList2021Entry") {
        throw new errors_1.ValidationError('The credentialStatus type must be "StatusList2021Entry"');
    }
    if (!("statusPurpose" in credentialStatus)) {
        throw new errors_1.ValidationError('The credentialStatus MUST contain a "statusPurpose" property');
    }
    const { statusPurpose } = credentialStatus;
    if (statusPurpose !== "revocation" && statusPurpose !== "suspension") {
        throw new errors_1.ValidationError('The credentialStatus "statusPurpose" property must be either "revocation" or "suspension"');
    }
    if (!("statusListIndex" in credentialStatus)) {
        throw new errors_1.ValidationError('The credentialStatus MUST contain a "statusListIndex" property');
    }
    if (typeof credentialStatus.statusListIndex !== "string") {
        throw new errors_1.ValidationError('The credentialStatus "statusListIndex" property must be a number expressed as a string');
    }
    const statusListIndex = parseInt(credentialStatus.statusListIndex, 10);
    if (Number.isNaN(statusListIndex)) {
        throw new errors_1.ValidationError('The credentialStatus "statusListIndex" property is not a valid number expressed as a string');
    }
    if (statusListIndex < 0) {
        throw new errors_1.ValidationError('The credentialStatus "statusListIndex" property must be greater or equal to 0');
    }
    if (!("statusListCredential" in credentialStatus)) {
        throw new errors_1.ValidationError('The credentialStatus MUST contain a "statusListCredential" property');
    }
    if (typeof credentialStatus.statusListCredential !== "string") {
        throw new errors_1.ValidationError('The credentialStatus "statusListCredential" property must be a string');
    }
    const statusListCredentialUrl = credentialStatus.statusListCredential;
    try {
        // eslint-disable-next-line no-new
        new URL(statusListCredentialUrl);
    }
    catch {
        // Error while parsing the URL
        throw new errors_1.ValidationError('The credentialStatus "statusListCredential" property must be a valid URL');
    }
    if (!statusListCredentialUrl.startsWith(config.trustedIssuersRegistry)) {
        throw new errors_1.ValidationError(`The credentialStatus "statusListCredential" property must be a URL from the Trusted Issuers Registry (${config.trustedIssuersRegistry})`);
    }
    // Fetch statusListCredentialUrl, verify it is a valid StatusList2021Credential and that the statusListIndex is not revoked or suspended
    let statusListCredentialUrlResponse;
    try {
        statusListCredentialUrlResponse = await axios_1.default.get(statusListCredentialUrl, {
            timeout: options.timeout ?? utils_1.AXIOS_TIMEOUT,
        });
    }
    catch (e) {
        throw new errors_1.ValidationError(`Unable to fetch the StatusList2021Credential: ${statusListCredentialUrl}. Reason: ${(0, utils_1.getErrorMessage)(e)}`);
    }
    // Parse and validate response. It must be a valid StatusList2021Credential JWT.
    const statusListCredentialJwt = statusListCredentialUrlResponse.data;
    if (typeof statusListCredentialJwt !== "string") {
        throw new errors_1.ValidationError("The StatusList2021Credential must be a JWT string");
    }
    let statusListCredential;
    try {
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        statusListCredential = await verifyVcJwt(statusListCredentialJwt, config, {
            ...options,
            // the Status List Credential does not require terms of use
            validateAccreditationWithoutTermsOfUse: false,
        });
    }
    catch (e) {
        throw new errors_1.ValidationError(`The StatusList2021Credential JWT is not valid: ${e instanceof Error ? e.message : "unknown error"}`);
    }
    // Possible improvements:
    // - Check that the issuer is the same as the issuer of the VC
    if (!("type" in statusListCredential.credentialSubject)) {
        throw new errors_1.ValidationError('The StatusList2021Credential "credentialSubject" property MUST contain a "type" property');
    }
    if (statusListCredential.credentialSubject.type !== "StatusList2021") {
        throw new errors_1.ValidationError('The StatusList2021Credential "credentialSubject.type" property MUST be "StatusList2021"');
    }
    if (!("statusPurpose" in statusListCredential.credentialSubject)) {
        throw new errors_1.ValidationError('The StatusList2021Credential "credentialSubject" property MUST contain a "statusPurpose" property');
    }
    if (statusListCredential.credentialSubject.statusPurpose !== statusPurpose) {
        throw new errors_1.ValidationError('The StatusList2021Credential "credentialSubject.statusPurpose" property MUST match the "statusPurpose" property of the VC');
    }
    if (!("encodedList" in statusListCredential.credentialSubject)) {
        throw new errors_1.ValidationError('The StatusList2021Credential "credentialSubject" property MUST contain a "encodedList" property');
    }
    const { encodedList } = statusListCredential.credentialSubject;
    if (typeof encodedList !== "string") {
        throw new errors_1.ValidationError('The StatusList2021Credential "credentialSubject.encodedList" property MUST be a string');
    }
    // The encodedList property of the credential subject MUST be the GZIP-compressed [RFC1952],
    // base-64 encoded [RFC4648] bitstring values for the associated range of verifiable credential
    // status values. The uncompressed bitstring MUST be at least 16KB in size. The bitstring MUST be
    // encoded such that the first index, with a value of zero (0), is located at the left-most bit
    // in the bitstring and the last index, with a value of one less than the length of the bitstring
    // (bitstring_length - 1), is located at the right-most bit in the bitstring.
    // Transform the base64 encoded string into a Uint8Array
    let decodedList;
    try {
        decodedList = base64_1.base64.baseDecode(encodedList);
    }
    catch (e) {
        throw new errors_1.ValidationError('The StatusList2021Credential "credentialSubject.encodedList" property MUST be a valid base64 string');
    }
    // Inflate decodedList
    const inflator = new pako_1.Inflate();
    inflator.push(decodedList);
    if (inflator.err) {
        throw new errors_1.ValidationError("The StatusList2021Credential is not a valid GZIP-compressed bitstring");
    }
    const inflatedList = inflator.result;
    const bytePosition = Math.floor(statusListIndex / 8);
    const bitPosition = statusListIndex % 8;
    const byte = inflatedList.at(bytePosition);
    if (byte === undefined) {
        throw new errors_1.ValidationError("The StatusList2021Credential encoded list doesn't contain the statusListIndex");
    }
    // Transform number to base2 string, pad with 0 to have 8 bits, get the bit at the bitPosition
    const bit = byte.toString(2).padStart(8, "0").at(bitPosition);
    // bit="0" -> ok, bit="1" -> revoked/suspended
    if (bit === "1") {
        throw new errors_1.ValidationError(`The credential is ${statusPurpose === "revocation" ? "revoked" : "suspended"}`);
    }
}
exports.validateStatusList2021Entry = validateStatusList2021Entry;
/**
 * Validates that the EbsiAccreditationEntry credential is not revoked nor suspended.
 *
 * @param credentialStatus - the credentialStatus object to validate
 * @param credentialSubject - the credentialSubject object related to the credentialStatus
 * @param config - a configuration object containing the URLs to the Trusted Issuers Registry
 * @param options - a configuration object containing the timeout for the HTTP requests
 */
async function validateEbsiAccreditationEntry(credentialStatus, credentialSubject, config, options) {
    if (credentialStatus.type !== "EbsiAccreditationEntry") {
        throw new errors_1.ValidationError('The credentialStatus type must be "EbsiAccreditationEntry"');
    }
    if (!credentialSubject.id) {
        throw new errors_1.ValidationError('The credentialSubject "id" property is required');
    }
    if (!credentialSubject.reservedAttributeId) {
        throw new errors_1.ValidationError('The credentialSubject "reservedAttributeId" property is required');
    }
    if (typeof credentialSubject.reservedAttributeId !== "string") {
        throw new errors_1.ValidationError('The credentialSubject "reservedAttributeId" property must be a valid string');
    }
    let decodedReservedAttributeId;
    try {
        decodedReservedAttributeId = base16_1.base16.baseDecode(credentialSubject.reservedAttributeId.replace("0x", "") // Remove 0x prefix if present. TIR API accepts both with and without prefix
        );
    }
    catch (e) {
        throw new errors_1.ValidationError('The credentialSubject "reservedAttributeId" property must be encoded in hexadecimal');
    }
    if (decodedReservedAttributeId.byteLength !== 32) {
        throw new errors_1.ValidationError('The credentialSubject "reservedAttributeId" property must be 32 bytes long');
    }
    const expectedAttributeUrl = `${config.trustedIssuersRegistry}/${credentialSubject.id}/attributes/${credentialSubject.reservedAttributeId}`;
    if (credentialStatus.id !== expectedAttributeUrl) {
        throw new errors_1.ValidationError(`The credentialStatus "id" property must match the expected attribute URL ${expectedAttributeUrl}`);
    }
    // Fetch attribute (assume response is correctly formatted)
    let attributeResponse;
    try {
        attributeResponse = await axios_1.default.get(credentialStatus.id, {
            timeout: options.timeout ?? utils_1.AXIOS_TIMEOUT,
        });
    }
    catch (e) {
        throw new errors_1.ValidationError(`Unable to fetch the attribute ${credentialStatus.id}. Reason: ${(0, utils_1.getErrorMessage)(e)}`);
    }
    // Parse and validate response
    const attributeData = attributeResponse.data;
    if (attributeData.did !== credentialSubject.id) {
        throw new errors_1.ValidationError(`The attribute "did" property must match the credentialSubject "id" property`);
    }
    const { attribute } = attributeData;
    if (attribute.issuerType === "Revoked") {
        throw new errors_1.ValidationError("The credential is revoked");
    }
}
exports.validateEbsiAccreditationEntry = validateEbsiAccreditationEntry;
/**
 * Validates that the credential is not revoked nor suspended when it contains a `credentialStatus`
 * property.
 *
 * @see https://w3c.github.io/vc-status-list-2021/
 *
 * @param payload - `EbsiVerifiableAttestation`
 * @param config - a configuration object containing the URLs to the Trusted Issuers Registry
 * @param options - a configuration object containing the timeout for the HTTP requests
 */
async function validateCredentialStatus(payload, config, options) {
    const { credentialStatus, credentialSubject } = payload;
    if (!credentialStatus) {
        // Return without throwing an error
        return;
    }
    if (credentialStatus.type === "StatusList2021Entry") {
        await validateStatusList2021Entry(credentialStatus, config, options);
        return;
    }
    if (credentialStatus.type === "EbsiAccreditationEntry") {
        await validateEbsiAccreditationEntry(credentialStatus, credentialSubject, config, options);
        return;
    }
    throw new errors_1.ValidationError(`The credentialStatus type ${credentialStatus.type} is not supported`);
}
exports.validateCredentialStatus = validateCredentialStatus;
/**
 * Validates the VC JWT properties. Ensures that all the properties are available and match the VC.
 *
 * Rules:
 * - The JWT payload "vc" property must be conform to the EBSI VA schema
 * - EBSI_JWT_VC_001 The JWT claims MUST match with the VC properties
 *
 * @param jwt - The VC JWT
 * @param timeout - Axios requests timeout. Default: 15 seconds
 * @param trustedHostnames - List of additional trusted hostnames running the EBSI Core Services APIs.
 */
function validateJwtProps(jwt, timeout, trustedHostnames) {
    // EBSI_JWT_VC_001: verify JWT props match payload
    let payload;
    let header;
    try {
        payload = (0, jose_1.decodeJwt)(jwt);
        header = (0, jose_1.decodeProtectedHeader)(jwt);
    }
    catch (e) {
        throw new errors_1.ValidationError("Unable to decode JWT VC");
    }
    /**
     * Header
     *
     * alg REQUIRED. The signature algorithm used to sign the VC.
     * kid REQUIRED. It MUST point to a DID URI resolving to an issuer's key in the DID document.
     * typ REQUIRED. MUST be JWT.
     */
    if (!header) {
        throw new errors_1.ValidationError("Invalid JWT header");
    }
    if (!header.alg || typeof header.alg !== "string") {
        throw new errors_1.ValidationError(`"alg" JWT header is required`);
    }
    if (!["ES256", "ES256K", "Ed25519", "EdDSA"].includes(header.alg)) {
        throw new errors_1.ValidationError(`${header.alg} is not a supported alg`);
    }
    if (!header.kid || typeof header.kid !== "string") {
        throw new errors_1.ValidationError(`"kid" JWT header is required`);
    }
    // In this test, we simply check if the kid is a valid EBSI DID.
    validateDid(header.kid.split("#")[0], false);
    if (!header.typ || header.typ !== "JWT") {
        throw new errors_1.ValidationError(`"typ" JWT header must be "JWT"`);
    }
    /**
     * Payload
     *
     * iss REQUIRED. MUST match the value of the property issuer of the Verifiable Credential.
     * sub REQUIRED. MUST match the value of the property credentialSubject.id of the Verifiable Credential.
     * jti REQUIRED. MUST match the value of the property id of Verifiable Credential.
     * iat REQUIRED. MUST match the value of the property issuanceDate of Verifiable Credential.
     * nbf REQUIRED. MUST match the value of the property validFrom of Verifiable Credential.
     * exp REQUIRED (if vc.expirationDate exists). MUST match the value of the property expirationDate of Verifiable Credential.
     * vc REQUIRED. MUST be a valid Verifiable Credential JSON object.
     */
    const { vc, iss, sub, jti, iat, nbf, exp } = payload;
    validateEbsiVerifiableAttestation(vc, timeout, trustedHostnames);
    if (!iss || iss !== vc.issuer) {
        throw new errors_1.ValidationError(`JWT "iss" property MUST match the VC issuer "${vc.issuer}"`);
    }
    if (!sub || sub !== vc.credentialSubject.id) {
        throw new errors_1.ValidationError(`JWT "sub" property MUST match the VC credentialSubject "${vc.credentialSubject.id || ""}"`);
    }
    if (!jti || jti !== vc.id) {
        throw new errors_1.ValidationError(`JWT "jti" property MUST match the VC ID "${vc.id}"`);
    }
    const issued = Math.floor(Date.parse(vc.issued) / 1000);
    if (!iat || iat !== issued) {
        throw new errors_1.ValidationError(`JWT "iat" property MUST match the VC issued "${issued}"`);
    }
    const validFrom = Math.floor(Date.parse(vc.validFrom) / 1000);
    if (!nbf || nbf !== validFrom) {
        throw new errors_1.ValidationError(`JWT "nbf" property MUST match the VC validFrom "${validFrom}"`);
    }
    if (vc.expirationDate) {
        const expirationDate = Math.floor(Date.parse(vc.expirationDate) / 1000);
        if (!exp || exp !== expirationDate) {
            throw new errors_1.ValidationError(`JWT "exp" property MUST match the VC expirationDate "${expirationDate}"`);
        }
    }
}
exports.validateJwtProps = validateJwtProps;
/**
 *
 * @param vc - The VC JWT
 * @param config - A configuration object containing the URLs to the different registries
 * @param options - Validation options
 * @returns The EBSI Verifiable Attestation
 */
async function verifyVcJwt(vc, config, options) {
    // EBSI_JWT_VC_001
    validateJwtProps(vc, options.timeout, options.trustedHostnames);
    const resolver = new did_resolver_1.Resolver({
        ...(0, ebsi_did_resolver_1.getResolver)({ registry: config.didRegistry }),
        ...(0, key_did_resolver_1.getResolver)(),
    });
    // TODO: memoize
    const documentLoader = async (iri) => {
        if (iri.startsWith(ebsi_did_resolver_1.EBSI_DID_METHOD_PREFIX) ||
            iri.startsWith(key_did_resolver_1.KEY_DID_METHOD_PREFIX)) {
            const { didDocument, didResolutionMetadata } = await resolver.resolve(iri, { timeout: options.timeout ?? utils_1.AXIOS_TIMEOUT });
            handleDidResolutionErrors(didDocument, didResolutionMetadata, iri);
            return {
                documentUrl: iri,
                document: didDocument,
            };
        }
        // Serve common contexts directly
        if (Object.prototype.hasOwnProperty.call(contexts_1.contexts, iri)) {
            return {
                documentUrl: iri,
                document: contexts_1.contexts[iri],
            };
        }
        // Fetch unknown documents
        const req = await (0, utils_1.memGet)(iri, options.timeout);
        return {
            documentUrl: iri,
            document: req.data,
        };
    };
    try {
        const verifyVcResult = await vc_js_1.verifiable.credential.verify({
            credential: vc,
            format: ["vc-jwt"],
            documentLoader,
            suite: [new json_web_signature_1.JsonWebSignature()],
        });
        if (!verifyVcResult.verified) {
            throw new errors_1.ValidationError("Invalid signature");
        }
    }
    catch (e) {
        const errorMessage = e instanceof Error ? e.message : "Reason unknown";
        // Fixes EBSIINT-6779
        if (errorMessage.includes("JWS.header contained unsupported alg")) {
            // Extract alg from error message
            const alg = errorMessage.split("JWS.header contained unsupported alg: ")[1];
            throw new errors_1.ValidationError(`VC JWT validation failed: the VC JWT 'alg' header (${alg}) doesn't match the algorithm of the verification method related to the VC JWT 'kid' header`);
        }
        throw new errors_1.ValidationError(`VC JWT validation failed: ${errorMessage}`);
    }
    // Additional EBSI rules
    const vcJwtPayload = (0, jose_1.decodeJwt)(vc);
    const vcJwtHeader = (0, jose_1.decodeProtectedHeader)(vc);
    const { vc: credentialPayload } = vcJwtPayload;
    validateContext(credentialPayload["@context"]);
    validateType(credentialPayload.type);
    // Validate dates (especially issuanceDate/validFrom)
    validateDates(credentialPayload, options?.validAt);
    // Verify issuer (EBSI_JWT_VC_002)
    await validateIssuer(credentialPayload, vcJwtPayload.iss, vcJwtHeader.kid || "", config, options.timeout);
    // Check if credentialSubject is a valid EBSI DID
    validateCredentialSubject(credentialPayload);
    // Validate that the VC is conform to the schema
    await validateCredentialSchema(credentialPayload, options.timeout, options.trustedHostnames);
    if (!options.skipAccreditationsValidation) {
        // Validate trust chain of accreditations
        await (0, validateAccreditations_1.validateAccreditations)(credentialPayload, options);
    }
    if (!options.skipStatusValidation) {
        await validateCredentialStatus(credentialPayload, config, options);
    }
    return credentialPayload;
}
exports.verifyVcJwt = verifyVcJwt;
//# sourceMappingURL=validators.js.map