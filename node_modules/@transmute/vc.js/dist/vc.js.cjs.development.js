'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var ldp = require('@transmute/linked-data-proof');
var jsonld = _interopDefault(require('@transmute/jsonld'));
var jsonldSchema = require('@transmute/jsonld-schema');
var moment = _interopDefault(require('moment'));
var jsonWebSignature = require('@transmute/json-web-signature');

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;

  _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

// Modified for leap seconds

var xmlDateSchemaRegex = /-?([1-9][0-9]{3,}|0[0-9]{3})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])T(([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?|(24:00:00(\.0+)?))(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?/; // Modified for leap seconds

var ISO_8601_FULL = /^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-2])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T]((([01]\d|2[0-3])((:?)[0-5]\d)?|24\:?00)([\.,]\d+(?!:))?)?(\17[0-5][0-9]([\.,]\d+)?|:60([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/;
var TIME_ZONE_OFFSET_MATCH = /[+-]\d\d:\d\d$/; // for the sake of safety, we check the date
// against ISO 8601 and moment.
// see also: https://github.com/w3c/vc-data-model/issues/782

var checkDate = function checkDate(datetime, isJWT) {
  if (isJWT === void 0) {
    isJWT = false;
  }

  var res = {
    valid: false,
    warnings: []
  }; // open source vc, make sure validation tests date strings are the right format for the date

  if (!ISO_8601_FULL.test(datetime)) {
    res.warnings.push(datetime + " is not a legal ISO 8601 Date Time.");
  }

  if (!xmlDateSchemaRegex.test(datetime)) {
    res.warnings.push(datetime + " is not a XMLSCHEMA11-2 date-time. See: https://www.w3.org/TR/vc-data-model/#issuance-date, https://www.w3.org/TR/xmlschema11-2/#dateTime");
  }

  moment.suppressDeprecationWarnings = true; // If leap second (60 seconds) make it a valid date

  var newDatetime = datetime;
  var isLeapSecond = false;

  try {
    if (newDatetime.split(":")[2].substring(0, 2) === "60") {
      newDatetime = newDatetime.replace("60", "59");
      var newDate = new Date(newDatetime);
      newDate.setSeconds(new Date(newDatetime).getSeconds() + 1);
      newDatetime = newDate.toISOString();
      isLeapSecond = true;
    }
  } catch (err) {}

  if (moment(newDatetime).toISOString() === null) {
    res.warnings.push(datetime + " could not be parsed and serialized as ISO 8601 Date Time.");
  }

  if (isJWT) {
    if (isLeapSecond) {
      res.warnings.push(datetime + " lost leap second information.");
    }

    if (TIME_ZONE_OFFSET_MATCH.test(datetime)) {
      res.warnings.push(datetime + " lost timezone offset information.");
    }

    if (new Date(newDatetime).getMilliseconds()) {
      res.warnings.push(datetime + " lost millisecond information.");
    }
  }

  moment.suppressDeprecationWarnings = false;
  res.valid = res.warnings.length === 0;
  return res;
};

function _getId(obj) {
  if (typeof obj === "string") {
    return obj;
  }

  if (!("id" in obj)) {
    return;
  }

  return obj.id;
}

var requireContext = function requireContext(credential) {
  if (!credential["@context"]) {
    throw new Error(["Verifiable credentials MUST include a @context property.", "See: https://www.w3.org/TR/vc-data-model/#dfn-context"].join(""));
  }
};

var requireDocumentLoader = function requireDocumentLoader(documentLoader) {
  if (!documentLoader) {
    throw new TypeError('"documentLoader" parameter is required for checking presentations.');
  }
};

var handleJWT = function handleJWT(credential) {
  var isJWT = false;
  var credentialObj;

  if (typeof credential === "string") {
    var _credential$split = credential.split("."),
        encodedHeader = _credential$split[0],
        encodedPayload = _credential$split[1];

    var header = JSON.parse(Buffer.from(encodedHeader, "base64").toString());

    if (!header.alg) {
      throw new Error("alg is required in JWT header");
    }

    var payload = JSON.parse(Buffer.from(encodedPayload, "base64").toString());
    credentialObj = payload.vc;
    isJWT = true;
  } else {
    credentialObj = credential;
  }

  return {
    isJWT: isJWT,
    credential: credentialObj
  };
};

var checkValidJsonLd = function checkValidJsonLd(credential, documentLoader) {
  try {
    return Promise.resolve(jsonldSchema.check({
      input: credential,
      documentLoader: documentLoader
    })).then(function (isValidJsonLd) {
      if (!isValidJsonLd.ok) {
        throw new Error("credential is not valid JSON-LD: " + JSON.stringify(isValidJsonLd.error, null, 2));
      }
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var requireType = function requireType(credential) {
  if (!credential["type"]) {
    throw new Error("Verifiable credentials MUST have a type specified. See: https://www.w3.org/TR/vc-data-model/#dfn-type");
  }
};

var requireCredentialSubject = function requireCredentialSubject(credential) {
  if (!credential["credentialSubject"]) {
    throw new Error("Verifiable credentials MUST include a credentialSubject property. See: https://www.w3.org/TR/vc-data-model/#credential-subject");
  }
};

var checkType = function checkType(credential) {
  if (!jsonld.getValues(credential, "type").includes("VerifiableCredential")) {
    throw new Error("Verifiable credentials type MUST include `VerifiableCredential`. See: https://www.w3.org/TR/vc-data-model/#dfn-type");
  }
};

var requireIssuer = function requireIssuer(credential) {
  if (!credential["issuer"]) {
    throw new Error("Verifiable credentials MUST include a issuer property. See: https://www.w3.org/TR/vc-data-model/#issuer");
  }
};

var requireIssuanceDate = function requireIssuanceDate(credential) {
  if (!credential["issuanceDate"]) {
    throw new Error("Verifiable credentials MUST include a issuanceDate. See: https://www.w3.org/TR/vc-data-model/#issuance-date");
  }
};

var checkIssuanceDate = function checkIssuanceDate(credential, isJWT, strict) {
  // check issuanceDate cardinality
  if (jsonld.getValues(credential, "issuanceDate").length > 1) {
    throw new Error('"issuanceDate" property can only have one value.');
  } // check issued is a date


  var res = checkDate(credential.issuanceDate, isJWT);

  if (!res.valid) {
    var message = ["issuanceDate is not valid: " + JSON.stringify(res.warnings, null, 2), "issuanceDate must be XML Datestring as defined in spec: https://w3c.github.io/vc-data-model/#issuance-date"].join("\n");

    if (strict == "warn") {
      console.warn(message);
    }

    if (strict == "throw") {
      throw new Error(message);
    }
  }
};

var checkExpirationDate = function checkExpirationDate(credential, isJWT, strict) {
  if ("expirationDate" in credential) {
    var res = checkDate(credential.expirationDate, isJWT);

    if (!res.valid) {
      var message = ["expirationDate is not valid: " + JSON.stringify(res.warnings, null, 2), "expirationDate must be XML Datestring as defined in spec: https://w3c.github.io/vc-data-model/#expiration"].join("\n");

      if (strict == "warn") {
        console.warn(message);
      }

      if (strict == "throw") {
        throw new Error(message);
      }
    }
  }
};

var checkIssuer = function checkIssuer(credential) {
  // check issuer cardinality
  if (jsonld.getValues(credential, "issuer").length > 1) {
    throw new Error('"issuer" property can only have one value.');
  } // https://www.rfc-editor.org/rfc/rfc3986#page-50


  var rfc3986Regex = new RegExp("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?");

  if ("issuer" in credential) {
    var issuer = _getId(credential.issuer);

    if (!issuer) {
      throw new Error("Verifiable credentials issuer:object MUST have an id. See: https://www.w3.org/TR/vc-data-model/#issuer");
    }

    if (!rfc3986Regex.test(issuer)) {
      throw new Error("Verifiable credentials issuer:string MUST be a RFC3986 URI. See: https://www.w3.org/TR/vc-data-model/#issuer, https://www.rfc-editor.org/rfc/rfc3986");
    }

    if (!issuer.includes(":")) {
      throw new Error("\"issuer\" id must be a URL: " + issuer);
    }
  }
};

var checkCredentialStatus = function checkCredentialStatus(credential) {
  if ("credentialStatus" in credential) {
    if (!credential.credentialStatus.id) {
      throw new Error('"credentialStatus" must include an id.');
    }

    if (!credential.credentialStatus.type) {
      throw new Error('"credentialStatus" must include a type.');
    }
  }
};

var checkEvidence = function checkEvidence(credential) {
  // check evidences are URLs
  // FIXME
  jsonld.getValues(credential, "evidence").forEach(function (evidence) {
    var evidenceId = _getId(evidence);

    if (evidenceId && !evidenceId.includes(":")) {
      throw new Error("\"evidence\" id must be a URL: " + evidence);
    }
  });
};

var checkId = function checkId(credential) {
  // https://www.rfc-editor.org/rfc/rfc3986#page-50
  var rfc3986Regex = new RegExp("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?");

  if (credential.id && !rfc3986Regex.test(credential.id)) {
    throw new Error(["Verifiable credentials id (if exists) MUST be a RFC3986 URI.", "See: https://www.w3.org/TR/vc-data-model/#dfn-id"].join(""));
  }
};

var requireFields = function requireFields(credential) {
  requireContext(credential);
  requireType(credential);
  requireCredentialSubject(credential);
  requireIssuer(credential);
  requireIssuanceDate(credential);
};

var checkFields = function checkFields(credential, isJWT, strict) {
  checkType(credential);
  checkIssuanceDate(credential, isJWT, strict);
  checkExpirationDate(credential, isJWT, strict);
  checkIssuer(credential);
  checkCredentialStatus(credential);
  checkEvidence(credential);
  checkId(credential);
};

var checkCredential = function checkCredential(credential, options) {
  try {
    var documentLoader = options.documentLoader;
    var strict = options.strict || "warn";

    if (options.strict === "ignore") {
      return Promise.resolve(undefined);
    }

    var _handleJWT = handleJWT(credential),
        isJWT = _handleJWT.isJWT,
        newCredential = _handleJWT.credential;

    credential = newCredential;
    requireDocumentLoader(documentLoader);
    requireFields(credential);
    checkFields(credential, isJWT, strict);
    return Promise.resolve(checkValidJsonLd(credential, documentLoader)).then(function () {
      return undefined;
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

// A type of promise-like that resolves synchronously and supports only one observer

const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== "undefined" ? (Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator"))) : "@@iterator";

const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== "undefined" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator"))) : "@@asyncIterator";

// Asynchronously call a function and send errors to recovery continuation
function _catch(body, recover) {
	try {
		var result = body();
	} catch(e) {
		return recover(e);
	}
	if (result && result.then) {
		return result.then(void 0, recover);
	}
	return result;
}

var AssertionProofPurpose = ldp.purposes.AssertionProofPurpose;
var CredentialIssuancePurpose = /*#__PURE__*/function (_AssertionProofPurpos) {
  _inheritsLoose(CredentialIssuancePurpose, _AssertionProofPurpos);

  function CredentialIssuancePurpose(_temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        controller = _ref.controller,
        date = _ref.date,
        maxTimestampDelta = _ref.maxTimestampDelta;

    return _AssertionProofPurpos.call(this, {
      controller: controller,
      date: date,
      maxTimestampDelta: maxTimestampDelta
    }) || this;
  }

  var _proto = CredentialIssuancePurpose.prototype;

  _proto.validate = function validate(proof, _ref2) {
    var document = _ref2.document,
        suite = _ref2.suite,
        verificationMethod = _ref2.verificationMethod,
        documentLoader = _ref2.documentLoader,
        expansionMap = _ref2.expansionMap;

    try {
      var _this2 = this;

      return Promise.resolve(_catch(function () {
        return Promise.resolve(_AssertionProofPurpos.prototype.validate.call(_this2, proof, {
          document: document,
          suite: suite,
          verificationMethod: verificationMethod,
          documentLoader: documentLoader,
          expansionMap: expansionMap
        })).then(function (result) {
          if (!result.valid) {
            throw result.error;
          }

          var issuer = typeof document.issuer === "string" ? document.issuer : document.issuer.id;

          if (!issuer) {
            throw new Error("Credential issuer is required.");
          }

          if (result.controller.id !== issuer) {
            throw new Error("Credential issuer must match the verification method controller.");
          }

          return {
            valid: true
          };
        });
      }, function (error) {
        return {
          valid: false,
          error: error
        };
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  return CredentialIssuancePurpose;
}(AssertionProofPurpose);

var createVerifiableCredential = function createVerifiableCredential(options) {
  try {
    var credential = options.credential,
        suite = options.suite,
        documentLoader = options.documentLoader;
    var strict = options.strict || "warn"; // run common credential checks

    if (!credential) {
      throw new TypeError('"credential" parameter is required for issuing.');
    }

    return Promise.resolve(checkCredential(credential, {
      documentLoader: documentLoader,
      strict: strict
    })).then(function () {
      if (!documentLoader) {
        throw new TypeError('"documentLoader" parameter is required for issuing.');
      }

      if (!suite) {
        throw new TypeError('"suite" parameter is required for issuing.');
      } // check to make sure the `suite` has required params
      // Note: verificationMethod defaults to publicKey.id, in suite constructor...
      // ...in some implementations...


      if (!suite.verificationMethod) {
        throw new TypeError('"suite.verificationMethod" property is required.');
      }

      var purpose = new CredentialIssuancePurpose();
      return ldp.sign(credential, _extends({
        purpose: purpose
      }, options));
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var verifyVerifiableCredential = function verifyVerifiableCredential(options) {
  try {
    var credential = options.credential,
        checkStatus = options.checkStatus,
        documentLoader = options.documentLoader;
    var compactProof = false;

    if (options.expansionMap !== undefined) {
      var message = "The default options are not being used.";
      throw new Error(message);
    }

    return Promise.resolve(_catch(function () {
      if (!credential) {
        throw new TypeError('A "credential" property is required for verifying.');
      } // run common credential checks


      return Promise.resolve(checkCredential(credential, {
        documentLoader: documentLoader
      })).then(function () {
        // if credential status is provided, a `checkStatus` function must be given
        if (credential.credentialStatus && typeof options.checkStatus !== "function") {
          throw new TypeError('A "checkStatus" function must be given to verify credentials with ' + '"credentialStatus".');
        }

        var purpose = new CredentialIssuancePurpose();
        return Promise.resolve(ldp.verify(credential, _extends({}, options, {
          purpose: purpose,
          compactProof: compactProof
        }))).then(function (result) {
          // if verification has already failed, skip status check
          if (!result.verified) {
            return result;
          }

          var _temp = function () {
            if (credential.credentialStatus) {
              return Promise.resolve(checkStatus(options)).then(function (_checkStatus) {
                result.statusResult = _checkStatus;

                if (!result.statusResult.verified) {
                  result.verified = false;
                }
              });
            }
          }();

          return _temp && _temp.then ? _temp.then(function () {
            return result;
          }) : result;
        });
      });
    }, function (error) {
      return {
        verified: false,
        results: [{
          credential: credential,
          verified: false,
          error: error
        }],
        error: error
      };
    }));
  } catch (e) {
    return Promise.reject(e);
  }
};

var checkPresentation = function checkPresentation(presentation, options) {
  try {
    var documentLoader = options.documentLoader,
        domain = options.domain,
        challenge = options.challenge;
    var strict = options.strict || "warn";

    if (typeof presentation === "string") {
      var _presentation$split = presentation.split("."),
          encodedHeader = _presentation$split[0],
          encodedPayload = _presentation$split[1];

      var header = JSON.parse(Buffer.from(encodedHeader, "base64").toString());

      if (!header.alg) {
        throw new Error("alg is required in JWT header");
      }

      var payload = JSON.parse(Buffer.from(encodedPayload, "base64").toString());
      presentation = payload.vp;

      if (payload.aud) {
        if (payload.aud !== domain) {
          throw new Error('"aud" and "domain" does not match this verifiable presentation');
        }
      }

      if (payload.nonce) {
        if (payload.nonce !== challenge) {
          throw new Error('"nonce" and "challenge" does not match this verifiable presentation');
        }
      }
    }

    if (!presentation["@context"]) {
      throw new Error("Verifiable Presentations MUST include a @context property.");
    }

    if (!documentLoader) {
      throw new TypeError('"documentLoader" parameter is required for checking presentations.');
    }

    return Promise.resolve(jsonldSchema.check({
      input: presentation,
      documentLoader: documentLoader
    })).then(function (isValidJsonLd) {
      if (!isValidJsonLd.ok) {
        throw new Error("presentation is not valid JSON-LD: " + JSON.stringify(isValidJsonLd.error, null, 2));
      }

      var types = jsonld.getValues(presentation, "type"); // check type presence

      if (!types.includes("VerifiablePresentation")) {
        throw new Error('"type" must include "VerifiablePresentation".');
      }

      var _temp = function () {
        if (presentation.verifiableCredential) {
          var credentials = Array.isArray(presentation.verifiableCredential) ? presentation.verifiableCredential : [presentation.verifiableCredential];
          return Promise.resolve(Promise.all(credentials.map(function (vc) {
            try {
              return Promise.resolve(checkCredential(vc, {
                documentLoader: documentLoader,
                strict: strict
              })).then(function () {});
            } catch (e) {
              return Promise.reject(e);
            }
          }))).then(function () {});
        }
      }();

      if (_temp && _temp.then) return _temp.then(function () {});
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var createVerifiablePresentation = function createVerifiablePresentation(options) {
  try {
    var presentation = options.presentation,
        domain = options.domain,
        challenge = options.challenge,
        documentLoader = options.documentLoader;
    var strict = options.strict || "warn";
    return Promise.resolve(checkPresentation(presentation, {
      documentLoader: documentLoader,
      strict: strict
    })).then(function () {
      var purpose = new ldp.purposes.AuthenticationProofPurpose({
        domain: domain,
        challenge: challenge
      });
      return ldp.sign(presentation, _extends({}, options, {
        purpose: purpose
      }));
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var getVerifierForJwt = function getVerifierForJwt(jwt, options) {
  try {
    var _jwt$split$splice$map = jwt.split(".").splice(0, 1).map(function (item) {
      return JSON.parse(Buffer.from(item, "base64").toString());
    }),
        header = _jwt$split$splice$map[0];

    if (!header.kid) {
      throw new Error('Transmute requires "kid" in vc-jwt headers. Otherwise key dereferencing is not always possible.');
    }

    var suite = Array.isArray(options.suite) ? options.suite[0] : options.suite;
    return Promise.resolve(suite.getVerificationMethod({
      proof: {
        verificationMethod: header.kid
      },
      documentLoader: options.documentLoader,
      instance: true // need this to get the class instance

    })).then(function (verificationMethod) {
      var _suite$key;

      if (!verificationMethod || !verificationMethod.useJwa) {
        throw new Error('Transmute requires "suite.getVerificationMethod" to return a key instance with member useJwa.');
      }

      if ((_suite$key = suite.key) !== null && _suite$key !== void 0 && _suite$key.alg) {
        verificationMethod.alg = suite.key.alg;
      }

      var _from = jsonWebSignature.JsonWebKey.from;
      return Promise.resolve(verificationMethod["export"]({
        type: "JsonWebKey2020"
      })).then(function (_verificationMethod$e) {
        return Promise.resolve(_from.call(jsonWebSignature.JsonWebKey, _verificationMethod$e, {
          detached: false
        })).then(function (k2) {
          var verifier = k2.verifier();
          return verifier;
        });
      });
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var decodeJwt = function decodeJwt(jwt) {
  var _jwt$split = jwt.split("."),
      encodedHeader = _jwt$split[0],
      encodedPayload = _jwt$split[1],
      encodedSignature = _jwt$split[2];

  var _map = [encodedHeader, encodedPayload].map(function (item) {
    return JSON.parse(Buffer.from(item, "base64").toString());
  }),
      header = _map[0],
      payload = _map[1];

  return {
    header: header,
    payload: payload,
    signature: encodedSignature
  };
};

var verifyVerifiableCredential$1 = function verifyVerifiableCredential(jwt, options) {
  try {
    var verifier = options.verifier,
        documentLoader = options.documentLoader;
    var strict = options.strict || "warn";
    return Promise.resolve(checkCredential(jwt, {
      documentLoader: documentLoader,
      strict: strict
    })).then(function () {
      return Promise.resolve(verifier.verify({
        signature: jwt
      }));
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var verifyCredentialsInPresentation = function verifyCredentialsInPresentation(presentation, options) {
  try {
    var result = {
      verified: false
    };
    return Promise.resolve(Promise.all(presentation.verifiableCredential.map(function (credential) {
      try {
        var _temp3 = function _temp3(_result) {
          if (_exit2) return _result;

          if (credential.credentialStatus && !options.checkStatus) {
            throw new Error("options.checkStatus is required to verify presentation of revocable credentials.");
          }

          return Promise.resolve(verifyVerifiableCredential(_extends({
            credential: credential
          }, options))).then(function (res) {
            return _extends({
              credentialId: credential.id
            }, res);
          });
        };

        var _exit2 = false;

        var _temp4 = function () {
          if (!credential["@context"]) {
            return Promise.resolve(getVerifierForJwt(credential, options)).then(function (verifier) {
              return Promise.resolve(verifyVerifiableCredential$1(credential, _extends({}, options, {
                verifier: verifier
              }))).then(function (res) {
                var decoded = decodeJwt(credential);
                var _credentialId$verifie = {
                  credentialId: decoded.payload.vc.id || undefined,
                  verified: res
                };
                _exit2 = true;
                return _credentialId$verifie;
              });
            });
          }
        }();

        return Promise.resolve(_temp4 && _temp4.then ? _temp4.then(_temp3) : _temp3(_temp4));
      } catch (e) {
        return Promise.reject(e);
      }
    }))).then(function (results) {
      result.verified = results.every(function (r) {
        return r.verified;
      });
      result.results = results;
      return result;
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var verifyVerifiablePresentation = function verifyVerifiablePresentation(options) {
  try {
    var _temp11 = function _temp11(_result2) {
      if (_exit4) return _result2;

      function _temp8() {
        function _temp6() {
          if (result.presentation && !result.credentials) {
            result.verified = result.presentation.verified;
          }

          if (result.presentation && result.credentials) {
            result.verified = result.presentation.verified && result.credentials.verified;
          }

          return result;
        }

        var _temp5 = function () {
          if (presentation.proof) {
            var purpose = new ldp.purposes.AuthenticationProofPurpose({
              domain: domain,
              challenge: challenge
            });
            return Promise.resolve(ldp.verify(presentation, _extends({}, options, {
              purpose: purpose
            }))).then(function (verification) {
              result.presentation = verification;
            });
          } else {
            result.presentation = result.credentials;
          }
        }();

        return _temp5 && _temp5.then ? _temp5.then(_temp6) : _temp6(_temp5);
      }

      if (!presentation.proof && !presentation.verifiableCredential || presentation.verifiableCredential && presentation.verifiableCredential.length === 0) {
        var message = 'presentation MUST contain "proof" or "verifiableCredential"';
        throw new Error(message);
      }

      if (!presentation.proof) {
        var _message = 'presentation MUST contain "proof" when strict';

        if (strict == "warn") {
          console.warn(_message);
        }

        if (strict == "throw") {
          throw new Error(_message);
        }
      }

      var result = {
        verified: false
      };

      var _temp7 = function () {
        if (presentation.verifiableCredential && presentation.verifiableCredential.length) {
          return Promise.resolve(verifyCredentialsInPresentation(presentation, options)).then(function (credentials) {
            result.credentials = credentials;

            if (!credentials.verified) {
              result.verified = false;
            }
          });
        }
      }();

      return _temp7 && _temp7.then ? _temp7.then(_temp8) : _temp8(_temp7);
    };

    var _exit4 = false;
    var documentLoader = options.documentLoader,
        domain = options.domain,
        challenge = options.challenge;
    var strict = options.strict || "warn";
    var presentation = options.presentation;

    if (!documentLoader) {
      throw new TypeError('"documentLoader" parameter is required for verifying.');
    }

    if (!presentation) {
      throw new TypeError('A "presentation" property is required for verifying.');
    }

    var _temp12 = _catch(function () {
      return Promise.resolve(checkPresentation(presentation, {
        documentLoader: documentLoader,
        strict: strict
      })).then(function () {});
    }, function (e) {
      var _verified$presentatio = {
        verified: false,
        presentation: e
      };
      _exit4 = true;
      return _verified$presentatio;
    });

    return Promise.resolve(_temp12 && _temp12.then ? _temp12.then(_temp11) : _temp11(_temp12));
  } catch (e) {
    return Promise.reject(e);
  }
};



var index = {
  __proto__: null,
  createVerifiableCredential: createVerifiableCredential,
  verifyVerifiableCredential: verifyVerifiableCredential,
  createVerifiablePresentation: createVerifiablePresentation,
  verifyVerifiablePresentation: verifyVerifiablePresentation
};

var createVcPayload = function createVcPayload(credential, options) {
  try {
    var documentLoader = options.documentLoader;
    var strict = options.strict || "warn";

    if (!credential.issuer) {
      throw new Error("Issuer is a required field.");
    }

    return Promise.resolve(checkCredential(credential, {
      documentLoader: documentLoader,
      strict: strict
    })).then(function () {
      var issuer = credential.issuer.id ? credential.issuer.id : credential.issuer;
      var subject = undefined;

      if (typeof credential.credentialSubject === "string" || credential.credentialSubject instanceof String) {
        subject = credential.credentialSubject;
      }

      if (typeof credential.credentialSubject === "object" && credential.credentialSubject !== null && credential.credentialSubject.id) {
        subject = credential.credentialSubject.id;
      }

      var payload = {
        iss: issuer,
        sub: subject,
        vc: credential,
        jti: credential.id,
        nbf: moment(credential.issuanceDate).unix()
      };

      if (credential.expirationDate) {
        payload.exp = moment(credential.expirationDate).unix();
      }

      return payload;
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var createVerifiableCredential$1 = function createVerifiableCredential(credential, options) {
  try {
    var signer = options.signer;
    return Promise.resolve(createVcPayload(credential, options)).then(function (payload) {
      return Promise.resolve(signer.sign({
        data: payload
      }));
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var createVpPayload = function createVpPayload(presentation, options) {
  try {
    var documentLoader = options.documentLoader,
        domain = options.domain,
        challenge = options.challenge;
    var strict = options.strict || "warn";

    if (!challenge) {
      throw new Error('"challenge" is required to create verifiable presentations (it will be used for the "nonce" value)');
    }

    return Promise.resolve(checkPresentation(presentation, {
      documentLoader: documentLoader,
      strict: strict,
      domain: domain,
      challenge: challenge
    })).then(function () {
      var payload = {};

      if (presentation.holder) {
        var holder = presentation.holder.id ? presentation.holder.id : presentation.holder;
        payload.iss = holder;
        payload.sub = holder;
      }

      payload.vp = presentation;

      if (domain) {
        payload.aud = domain;
      }

      if (challenge) {
        payload.nonce = challenge;
      }

      return payload;
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var createVerifiablePresentation$1 = function createVerifiablePresentation(presentation, options) {
  try {
    var signer = options.signer;
    return Promise.resolve(createVpPayload(presentation, options)).then(function (payload) {
      return Promise.resolve(signer.sign({
        data: payload
      }));
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var verifyVerifiablePresentation$1 = function verifyVerifiablePresentation(jwt, options) {
  try {
    var verifier = options.verifier,
        documentLoader = options.documentLoader,
        domain = options.domain,
        challenge = options.challenge;
    var strict = options.strict || "warn";
    return Promise.resolve(checkPresentation(jwt, {
      documentLoader: documentLoader,
      strict: strict,
      domain: domain,
      challenge: challenge
    })).then(function () {
      return Promise.resolve(verifier.verify({
        signature: jwt
      }));
    });
  } catch (e) {
    return Promise.reject(e);
  }
};



var index$1 = {
  __proto__: null,
  createVcPayload: createVcPayload,
  createVerifiableCredential: createVerifiableCredential$1,
  verifyVerifiableCredential: verifyVerifiableCredential$1,
  createVpPayload: createVpPayload,
  createVerifiablePresentation: createVerifiablePresentation$1,
  verifyVerifiablePresentation: verifyVerifiablePresentation$1
};

var create = function create(options) {
  try {
    var _temp4 = function _temp4() {
      var _exit = false;

      var _temp = function () {
        if (options.format.includes("vc-jwt")) {
          var suite = Array.isArray(options.suite) ? options.suite[0] : options.suite;
          var key = suite.key;

          if (!key || !key.useJwa) {
            throw new Error("Cannot create credential when suite does not contain a key that supports useJwa.");
          }

          var _from2 = jsonWebSignature.JsonWebKey.from;
          return Promise.resolve(key["export"]({
            type: "JsonWebKey2020",
            privateKey: true
          })).then(function (_key$export) {
            return Promise.resolve(_from2.call(jsonWebSignature.JsonWebKey, _key$export, {
              detached: false,
              header: {
                kid: key.id
              }
            })).then(function (k2) {
              var signer = k2.signer();
              return Promise.resolve(createVcPayload(options.credential, options)).then(function (payload) {
                var _result$items2 = result.items,
                    _push2 = _result$items2.push;
                return Promise.resolve(signer.sign({
                  data: payload
                })).then(function (_signer$sign) {
                  _push2.call(_result$items2, _signer$sign);
                });
              });
            });
          });
        }
      }();

      return _temp && _temp.then ? _temp.then(function (_result) {
        return _exit ? _result : result;
      }) : _exit ? _temp : result;
    };

    var result = {
      items: []
    };

    if (!options.format) {
      options.format = ["vc"];
    }

    var _temp5 = function () {
      if (options.format.includes("vc")) {
        var _result$items3 = result.items,
            _push3 = _result$items3.push;
        return Promise.resolve(createVerifiableCredential({
          credential: options.credential,
          suite: options.suite,
          documentLoader: options.documentLoader
        })).then(function (_ld$createVerifiableC) {
          _push3.call(_result$items3, _ld$createVerifiableC);
        });
      }
    }();

    return Promise.resolve(_temp5 && _temp5.then ? _temp5.then(_temp4) : _temp4(_temp5));
  } catch (e) {
    return Promise.reject(e);
  }
};

var _excluded = ["proof"];
var derive = function derive(options) {
  try {
    var result = {
      items: []
    };

    if (!options.format) {
      options.format = ["vc"];
    }

    var credential = options.credential,
        frame = options.frame,
        suite = options.suite,
        documentLoader = options.documentLoader;

    var proof = credential.proof,
        document = _objectWithoutPropertiesLoose(credential, _excluded);

    if (!suite.deriveProof) {
      throw new Error("Suite requires deriveProof");
    }

    return Promise.resolve(suite.deriveProof({
      document: document,
      proof: _extends({}, proof, {
        "@context": document["@context"]
      }),
      revealDocument: frame,
      documentLoader: documentLoader
    })).then(function (derivationResult) {
      var derivedCredential = _extends({}, derivationResult.document, {
        proof: derivationResult.proof
      });

      delete derivedCredential.proof["@context"];
      result.items.push(derivedCredential);
      return result;
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var verify = function verify(options) {
  try {
    var _temp5 = function _temp5() {
      function _temp2() {
        // Signature
        var proofCheckFailed = !!(result.error && result.error.find(function (e) {
          var _e$proofResult;

          return (e === null || e === void 0 ? void 0 : (_e$proofResult = e.proofResult) === null || _e$proofResult === void 0 ? void 0 : _e$proofResult.verified) === false;
        }));

        if (!result.verified && proofCheckFailed) {
          var description = "This credential has a invalid signature";
          result.verifications.push({
            status: "bad",
            title: "Proof",
            description: description
          });
        } else {
          var _options$credential$p, _options$credential$p2;

          result.verifications.push({
            status: "good",
            title: "Proof",
            description: (_options$credential$p = (_options$credential$p2 = options.credential.proof) === null || _options$credential$p2 === void 0 ? void 0 : _options$credential$p2.verificationMethod) !== null && _options$credential$p !== void 0 ? _options$credential$p : jwtVerificationMethod
          });
        } // Activation


        if (credential.issuanceDate) {
          var now = moment();
          var issuanceDate = moment(credential.issuanceDate);

          if (now.isAfter(issuanceDate)) {
            result.verifications.push({
              status: "good",
              title: "Activation",
              description: "This credential activated " + issuanceDate.fromNow()
            });
          } else {
            result.verifications.push({
              status: "bad",
              title: "Activation",
              description: "This credential activates " + issuanceDate.fromNow()
            });
          }
        } // Expiration


        if (credential.expirationDate) {
          var _now = moment();

          var expirationDate = moment(credential.expirationDate);

          if (_now.isBefore(expirationDate)) {
            result.verifications.push({
              status: "good",
              title: "Expired",
              description: "This credential expires " + expirationDate.fromNow()
            });
          } else {
            result.verifications.push({
              status: "bad",
              title: "Expired",
              description: "This credential expired " + expirationDate.fromNow()
            });
          }
        } // Revocation Status


        if (credential.credentialStatus) {
          var statusCheckFailed = !!(result.error && result.error.find(function (e) {
            var _e$statusResult;

            return (e === null || e === void 0 ? void 0 : (_e$statusResult = e.statusResult) === null || _e$statusResult === void 0 ? void 0 : _e$statusResult.verified) === false;
          }));

          if (!result.verified && statusCheckFailed) {
            result.verifications.push({
              status: "bad",
              title: "Revocation",
              description: "This credential has been revoked."
            });
          } else {
            result.verifications.push({
              status: "good",
              title: "Revocation",
              description: "This credential has not been revoked."
            });
          }
        }

        return result;
      }

      // vc-jwt's are strings with an encoded vc member that conforms to the data model
      var jwtVerificationMethod = "";

      var _temp = function () {
        if (options.format.includes("vc-jwt") && !options.credential["@context"]) {
          return Promise.resolve(getVerifierForJwt(options.credential, options)).then(function (verifier) {
            return Promise.resolve(verifier.verify({
              signature: options.credential
            })).then(function (verified) {
              var _decodedString$header, _decodedString$header2;

              result.verified = verified;
              var decodedString = decodeJwt(options.credential);
              credential = decodedString.payload.vc;
              jwtVerificationMethod = (_decodedString$header = decodedString === null || decodedString === void 0 ? void 0 : (_decodedString$header2 = decodedString.header) === null || _decodedString$header2 === void 0 ? void 0 : _decodedString$header2.kid) !== null && _decodedString$header !== void 0 ? _decodedString$header : typeof decodedString.payload.vc.issuer === "object" ? decodedString.payload.vc.issuer.id : decodedString.payload.vc.issuer;
            });
          });
        }
      }();

      return _temp && _temp.then ? _temp.then(_temp2) : _temp2(_temp);
    };

    var credential = options.credential;
    var result = {
      verified: false,
      verifications: []
    };

    if (!options.format) {
      options.format = ["vc"];
    }

    var _temp6 = function () {
      if (options.format.includes("vc") && options.credential["@context"]) {
        return Promise.resolve(verifyVerifiableCredential({
          credential: options.credential,
          suite: options.suite,
          documentLoader: options.documentLoader,
          checkStatus: options.checkStatus,
          expansionMap: options.expansionMap
        })).then(function (res) {
          result.verified = res.verified;

          if (!result.verified) {
            result.error = [];

            if (res && res.statusResult && !res.statusResult.verified) {
              result.error.push({
                statusResult: res.statusResult
              });
            }

            if (res && res.results[0] && !res.results[0].verified) {
              if (res.results[0].error, res.results[0].error.message.indexOf("Invalid JSON-LD") >= 0) {
                result.error.push("This credential contains invalid JSON-LD allowing it to be mutable.");
              }

              result.error.push({
                proofResult: res.results[0].verified
              });
            }

            if (res.error) {
              result.error.push(res.error);
            }
          }
        });
      }
    }();

    return Promise.resolve(_temp6 && _temp6.then ? _temp6.then(_temp5) : _temp5(_temp6));
  } catch (e) {
    return Promise.reject(e);
  }
};

var credential = {
  create: create,
  derive: derive,
  verify: verify
};

var create$1 = function create(options) {
  try {
    var _temp4 = function _temp4() {
      var _exit = false;

      var _temp = function () {
        if (options.format.includes("vp-jwt")) {
          var suite = Array.isArray(options.suite) ? options.suite[0] : options.suite;
          var key = suite.key;

          if (!key || !key.useJwa) {
            throw new Error("Cannot create credential when suite does not contain a key that supports useJwa.");
          }

          var _from2 = jsonWebSignature.JsonWebKey.from;
          return Promise.resolve(key["export"]({
            type: "JsonWebKey2020",
            privateKey: true
          })).then(function (_key$export) {
            return Promise.resolve(_from2.call(jsonWebSignature.JsonWebKey, _key$export, {
              detached: false,
              header: {
                kid: key.id
              }
            })).then(function (k2) {
              var signer = k2.signer();
              return Promise.resolve(createVpPayload(options.presentation, options)).then(function (payload) {
                var _result$items2 = result.items,
                    _push2 = _result$items2.push;
                return Promise.resolve(signer.sign({
                  data: payload
                })).then(function (_signer$sign) {
                  _push2.call(_result$items2, _signer$sign);
                });
              });
            });
          });
        }
      }();

      return _temp && _temp.then ? _temp.then(function (_result) {
        return _exit ? _result : result;
      }) : _exit ? _temp : result;
    };

    var result = {
      items: []
    };

    if (!options.format) {
      options.format = ["vp"];
    }

    var _temp5 = function () {
      if (options.format.includes("vp")) {
        var _result$items3 = result.items,
            _push3 = _result$items3.push;
        return Promise.resolve(createVerifiablePresentation({
          presentation: options.presentation,
          suite: options.suite,
          domain: options.domain,
          challenge: options.challenge,
          documentLoader: options.documentLoader
        })).then(function (_ld$createVerifiableP) {
          _push3.call(_result$items3, _ld$createVerifiableP);
        });
      }
    }();

    return Promise.resolve(_temp5 && _temp5.then ? _temp5.then(_temp4) : _temp4(_temp5));
  } catch (e) {
    return Promise.reject(e);
  }
};

var verify$1 = function verify(options) {
  try {
    var result = {
      verified: false
    };

    if (!options.format) {
      options.format = ["vp"];
    }

    if (options.format.includes("vp") && options.presentation["@context"]) {
      return Promise.resolve(verifyVerifiablePresentation({
        presentation: options.presentation,
        suite: options.suite,
        domain: options.domain,
        challenge: options.challenge,
        checkStatus: options.checkStatus,
        documentLoader: options.documentLoader
      }));
    } // vp-jwt's are strings with an encoded vp member that conforms to the data model


    var _temp2 = function () {
      if (options.format.includes("vp-jwt") && !options.presentation["@context"]) {
        return Promise.resolve(getVerifierForJwt(options.presentation, options)).then(function (verifier) {
          return Promise.resolve(verifier.verify({
            signature: options.presentation
          })).then(function (verified) {
            result.verified = verified;
          });
        });
      }
    }();

    return Promise.resolve(_temp2 && _temp2.then ? _temp2.then(function () {
      return result;
    }) : result);
  } catch (e) {
    return Promise.reject(e);
  }
};

var presentation = {
  create: create$1,
  verify: verify$1
};

var jwt = {
  decode: decodeJwt
};
var verifiable = {
  credential: credential,
  presentation: presentation,
  jwt: jwt
};

exports.jwt = index$1;
exports.ld = index;
exports.verifiable = verifiable;
//# sourceMappingURL=vc.js.cjs.development.js.map
